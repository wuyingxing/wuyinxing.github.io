<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Javascript模块化编程 — RequireJS | Hexo</title>

  <meta name="keywords" content="Javascript模块化编程 — RequireJS ">

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RequireJS是一个工具库，主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载，从而提高代码的性能和可维护性。它的模块管理遵守AMD规范（Asynchronous Module Definition）。
RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。
前言入门时，我们所有Javascript代码">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript模块化编程 — RequireJS">
<meta property="og:url" content="http://yoursite.com/2016/05/25/require-1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="RequireJS是一个工具库，主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载，从而提高代码的性能和可维护性。它的模块管理遵守AMD规范（Asynchronous Module Definition）。
RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。
前言入门时，我们所有Javascript代码">
<meta property="og:updated_time" content="2016-05-26T01:27:01.561Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript模块化编程 — RequireJS">
<meta name="twitter:description" content="RequireJS是一个工具库，主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载，从而提高代码的性能和可维护性。它的模块管理遵守AMD规范（Asynchronous Module Definition）。
RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。
前言入门时，我们所有Javascript代码">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/my.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">wuyinxing</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">关于自己</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/wuyinxing" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/wuyinxing" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://zhihu.com/people/wuyinxing" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/API/" style="font-size: 20px;">API</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Node/" style="font-size: 10px;">Node</a> <a href="/tags/base/" style="font-size: 10px;">base</a> <a href="/tags/event/" style="font-size: 10px;">event</a> <a href="/tags/form/" style="font-size: 10px;">form</a> <a href="/tags/globle/" style="font-size: 10px;">globle</a> <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/jQuery/" style="font-size: 20px;">jQuery</a> <a href="/tags/layout/" style="font-size: 10px;">layout</a> <a href="/tags/require/" style="font-size: 10px;">require</a> <a href="/tags/scroll/" style="font-size: 10px;">scroll</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/window/" style="font-size: 10px;">window</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">wuyinxing</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/my.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">wuyinxing</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于自己</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wuyinxing" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/wuyinxing" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://zhihu.com/people/wuyinxing" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-require-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/25/require-1/" class="article-date">
  	<time datetime="2016-05-25T07:52:03.448Z" itemprop="datePublished">2016-05-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Javascript模块化编程 — RequireJS
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/require/">require</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RequireJS是一个工具库，主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载，从而提高代码的性能和可维护性。它的模块管理遵守AMD规范（Asynchronous Module Definition）。</p>
<p>RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>入门时，我们所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。慢慢的，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。就形成了下面的结构模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  　&lt;script src=&quot;aa.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;bb.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;cc.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;dd.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;ee.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;ff.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的aa.js要在bb.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p>
<p><strong>require.js的诞生，就是为了解决这两个问题：</strong></p>
<blockquote>
<p>1）实现js文件的异步加载，避免网页失去响应；</p>
<p>2）管理模块之间的依赖性，便于代码的编写和维护。</p>
</blockquote>
<h2 id="require-js的加载很简介"><a href="#require-js的加载很简介" class="headerlink" title="require.js的加载很简介"></a>require.js的加载很简介</h2><p>使用require.js的第一步，是先去官方网站下载最新版本。<br>下载后，假定把它放在js子目录下面，就可以加载了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。</p>
<p>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<p>main.js , 是整个网页的入口代码 , 所有代码都从这儿开始运行。</p>
<p>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">alert(&quot;加载成功！&quot;);</span><br></pre></td></tr></table></figure>
<p>但这样的话，就没必要使用require.js了。真正常见的情况是依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> // main.js</span><br><span class="line">require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123;</span><br><span class="line">　　　　// some code here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</p>
<p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<p>下面，我们看一个实际的例子。<br>如果依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;jquery&apos;, &apos;underscore&apos;, &apos;backbone&apos;], function ($, _, Backbone)&#123;</span><br><span class="line">　　　　// some code here</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。代码就写在回调函数中。</p>
<p>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在 main.js的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;lib/jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;lib/underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;lib/backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>另一种则是直接改变基目录（baseUrl）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　baseUrl: &quot;js/lib&quot;,</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>如果某个模块在另一台主机上，也可以直接指定它的网址，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p>
<h1 id="对上述概念的详细解释"><a href="#对上述概念的详细解释" class="headerlink" title=" 对上述概念的详细解释 "></a><strong> 对上述概念的详细解释 </strong></h1><h2 id="1-基本API"><a href="#1-基本API" class="headerlink" title="1.基本API"></a>1.基本API</h2><p>require会定义三个变量：define,require,requirejs，其中require === requirejs，一般使用require更简短</p>
<blockquote>
<p>define 从名字就可以看出这个api是用来定义一个模块,RequireJS要求每个模块放在一个单独的文件里。</p>
<p>require 加载依赖模块，并执行加载完后的回调函数</p>
</blockquote>
<h3 id="1-1-define方法：定义模块"><a href="#1-1-define方法：定义模块" class="headerlink" title="1.1 define方法：定义模块"></a>1.1 define方法：定义模块</h3><h4 id="（1）独立模块"><a href="#（1）独立模块" class="headerlink" title="（1）独立模块"></a>（1）独立模块</h4><p>如果被定义的模块是一个独立模块，不需要依赖任何其他模块，可以直接用define方法生成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">    method1: function() &#123;&#125;,</span><br><span class="line">    method2: function() &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码生成了一个拥有method1、method2两个方法的模块。</p>
<p>把对象写成一个函数，该函数的返回值就是输出的模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(function () &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">	    method1: function() &#123;&#125;,</span><br><span class="line">		method2: function() &#123;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>后一种写法的自由度更高一点，可以在函数体内写一些模块初始化代码。</p>
<p>值得指出的是，define定义的模块可以返回任何值，不限于对象。</p>
<h4 id="（2）非独立模块"><a href="#（2）非独立模块" class="headerlink" title="（2）非独立模块"></a>（2）非独立模块</h4><p>如果被定义的模块需要依赖其他模块，则define方法必须采用下面的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;module1&apos;, &apos;module2&apos;], function(m1, m2) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>define方法的第一个参数是一个数组，它的成员是当前模块所依赖的模块。</strong></p>
<p>比如，[‘module1’, ‘module2’]表示我们定义的这个新模块依赖于module1模块和module2模块，只有先加载这两个模块，新模块才能正常运行。一般情况下，module1模块和module2模块指的是，当前目录下的module1.js文件和module2.js文件，等同于写成[’./module1’, ‘./module2’]。</p>
<p><strong>define方法的第二个参数是一个函数，当前面数组的所有成员加载成功后，它将被调用。</strong></p>
<p>它的参数与数组的成员一一对应，比如function(m1, m2)就表示，这个函数的第一个参数m1对应module1模块，第二个参数m2对应module2模块。这个函数必须返回一个对象，供其他模块调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;module1&apos;, &apos;module2&apos;], function(m1, m2) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        method: function() &#123;</span><br><span class="line">            m1.methodA();</span><br><span class="line">            m2.methodB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码表示新模块返回一个对象，该对象的method方法就是外部调用的接口，menthod方法内部调用了m1模块的methodA方法和m2模块的methodB方法。</p>
<p>需要注意的是，回调函数必须返回一个对象，这个对象就是你定义的模块。</p>
<p>如果依赖的模块很多，参数与模块一一对应的写法非常麻烦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">    [ &apos;dep1&apos;, &apos;dep2&apos;, &apos;dep3&apos;, &apos;dep4&apos;, &apos;dep5&apos;, &apos;dep6&apos;, &apos;dep7&apos;, &apos;dep8&apos;],</span><br><span class="line">    function(dep1,   dep2,   dep3,   dep4,   dep5,   dep6,   dep7,   dep8)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>为了避免像上面代码那样繁琐的写法，RequireJS提供一种更简单的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">    function (require) &#123;</span><br><span class="line">        var dep1 = require(&apos;dep1&apos;),</span><br><span class="line">            dep2 = require(&apos;dep2&apos;),</span><br><span class="line">            dep3 = require(&apos;dep3&apos;),</span><br><span class="line">            dep4 = require(&apos;dep4&apos;),</span><br><span class="line">            dep5 = require(&apos;dep5&apos;),</span><br><span class="line">            dep6 = require(&apos;dep6&apos;),</span><br><span class="line">            dep7 = require(&apos;dep7&apos;),</span><br><span class="line">            dep8 = require(&apos;dep8&apos;);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面是一个define实际运用的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;math&apos;, &apos;graph&apos;], </span><br><span class="line">    function ( math, graph ) &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">            plot: function(x, y)&#123;</span><br><span class="line">                return graph.drawPie(math.randomGrid(x,y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码定义的模块依赖math和graph两个库，然后返回一个具有plot接口的对象。</p>
<p>另一个实际的例子是，通过判断浏览器是否为IE，而选择加载zepto或jQuery。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define((&apos;__proto__&apos; in &#123;&#125; ? [&apos;zepto&apos;] : [&apos;jquery&apos;]), function($) &#123;</span><br><span class="line">    return $;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个中间模块，该模块先判断浏览器是否支持<strong>proto</strong>属性（除了IE，其他浏览器都支持），如果返回true，就加载zepto库，否则加载jQuery库。</p>
<h3 id="1-2-require方法：调用模块"><a href="#1-2-require方法：调用模块" class="headerlink" title="1.2 require方法：调用模块"></a>1.2 require方法：调用模块</h3><p>require方法用于调用模块。它的参数与define方法类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;a&apos;, &apos;b&apos;], function ( a, b ) &#123;</span><br><span class="line">        b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面方法表示加载a和b两个模块，当这两个模块都加载成功后，执行一个回调函数。该回调函数就用来完成具体的任务。</p>
<p>require方法的第一个参数，是一个表示依赖关系的数组。这个数组可以写得很灵活，请看下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require( [ window.JSON ? undefined : &apos;util/json2&apos; ], function ( JSON ) &#123;</span><br><span class="line">  JSON = JSON || window.JSON;</span><br><span class="line"></span><br><span class="line">  console.log( JSON.parse( &apos;&#123; &quot;JSON&quot; : &quot;HERE&quot; &#125;&apos; ) );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码加载JSON模块时，首先判断浏览器是否原生支持JSON对象。如果是的，则将undefined传入回调函数，否则加载util目录下的json2模块。</p>
<p>require方法也可以用在define方法内部。(define中介绍多模块加载提到过)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(function (require) &#123;</span><br><span class="line">   var otherModule = require(&apos;otherModule&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面的例子显示了如何动态加载模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(function ( require ) &#123;</span><br><span class="line">    var isReady = false, foobar;</span><br><span class="line"></span><br><span class="line">    require([&apos;foo&apos;, &apos;bar&apos;], function (foo, bar) &#123;</span><br><span class="line">        isReady = true;</span><br><span class="line">        foobar = foo() + bar();</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    return &#123;</span><br><span class="line">        isReady: isReady,</span><br><span class="line">        foobar: foobar</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码所定义的模块，内部加载了foo和bar两个模块，在没有加载完成前，isReady属性值为false，加载完成后就变成了true。因此，可以根据isReady属性的值，决定下一步的动作。</p>
<p>下面的例子是模块的输出结果是一个promise对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;lib/Deferred&apos;], function( Deferred )&#123;</span><br><span class="line">    var defer = new Deferred(); </span><br><span class="line">    require([&apos;lib/templates/?index.html&apos;,&apos;lib/data/?stats&apos;],</span><br><span class="line">        function( template, data )&#123;</span><br><span class="line">            defer.resolve(&#123; template: template, data:data &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    return defer.promise();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码的define方法返回一个promise对象，可以在该对象的then方法，指定下一步的动作。</p>
<p>如果服务器端采用JSONP模式，则可以直接在require中调用，方法是指定JSONP的callback参数为define。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require( [ </span><br><span class="line">    &quot;http://someapi.com/foo?callback=define&quot;</span><br><span class="line">], function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>require方法允许添加第三个参数，即错误处理的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require(</span><br><span class="line">    [ &quot;backbone&quot; ], </span><br><span class="line">    function ( Backbone ) &#123;</span><br><span class="line">        return Backbone.View.extend(&#123; /* ... */ &#125;);</span><br><span class="line">    &#125;, </span><br><span class="line">    function (err) &#123;</span><br><span class="line">		// ...</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>require对象还允许指定一个全局性的Error事件的监听函数。所有没有被上面的方法捕获的错误，都会被触发这个监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requirejs.onError = function (err) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-配置config方法"><a href="#3-配置config方法" class="headerlink" title="3 配置config方法"></a>3 配置config方法</h2><p>require方法本身也是一个对象，它带有一个config方法，用来配置require.js运行参数。config方法接受一个对象作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这里的jquery模块定义多个位置(2个位置) 如果第一个位置加载失败，则加载第二个位置</span><br><span class="line">require.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        jquery: [</span><br><span class="line">            &apos;//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.0/jquery.min.js&apos;,</span><br><span class="line">            &apos;lib/jquery&apos;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>config方法的参数对象有以下主要成员：</p>
<p>（<strong>1）paths</strong></p>
<p>paths参数指定各个模块的位置。这个位置可以是同一个服务器上的相对位置，也可以是外部网址。<strong>可以为每个模块定义多个位置</strong>，如果第一个位置加载失败，则加载第二个位置，上面的示例就表示如果CDN加载失败，则加载服务器上的备用脚本。需要注意的是，指定本地文件路径时，可以省略文件最后的js后缀名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&quot;jquery&quot;], function($) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码加载jquery模块，因为jquery的路径已经在paths参数中定义了，所以就会到事先设定的位置下载。</p>
<p><strong>（2）baseUrl</strong></p>
<p>baseUrl参数指定本地模块位置的基准目录，即本地模块的路径是相对于哪个目录的。该属性通常由require.js加载时的data-main属性指定。</p>
<p><strong>（3）shim</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        &quot;backbone&quot;: &quot;vendor/backbone&quot;,</span><br><span class="line">        &quot;underscore&quot;: &quot;vendor/underscore&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    shim: &#123;</span><br><span class="line">        &quot;backbone&quot;: &#123;</span><br><span class="line">            deps: [ &quot;underscore&quot; ],</span><br><span class="line">            exports: &quot;Backbone&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;underscore&quot;: &#123;</span><br><span class="line">            exports: &quot;_&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中的backbone和underscore就是非AMD规范的库。shim指定它们的依赖关系（backbone依赖于underscore），以及输出符号（backbone为“Backbone”，underscore为“_”）。</p>
<p>有些库不是AMD兼容的，这时就需要指定shim属性的值。shim可以理解成“垫片”，用来帮助require.js加载非AMD规范的库。</p>
<h2 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h2><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。</p>
<p>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p>
<p>举例来说，md1和md2这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　shim: &#123;</span><br><span class="line">　　　　　　&apos;md1&apos;:&#123;</span><br><span class="line">　　　　　　　　exports: &apos;md.aa&apos;</span><br><span class="line">　　　　　　&#125;,</span><br><span class="line">　　　　　　&apos;md2&apos;: &#123;</span><br><span class="line">　　　　　　　　deps: [&apos;jquery&apos;, &apos;myQuery&apos;],</span><br><span class="line">　　　　　　　　exports: &apos;md.bb&apos;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义:</p>
<blockquote>
<p>（1）exports值（输出的变量名），表明这个模块外部调用时的名称；</p>
<p>（2）deps数组，表明该模块的依赖性。</p>
</blockquote>
<p>比如，jQuery的插件可以这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　shim: &#123;</span><br><span class="line">　　　　&apos;jquery.scroll&apos;: &#123;</span><br><span class="line">　　　　　　deps: [&apos;jquery&apos;],</span><br><span class="line">　　　　　　exports: &apos;jQuery.fn.scroll&apos;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>RequireJS允许使用插件，加载各种格式的数据。完整的插件清单可以查看 <a href="https://github.com/requirejs/requirejs/wiki/Plugins" title="插件" target="_blank" rel="external"><strong>require插件</strong></a>。</p>
<p>下面是插件的例子。</p>
<p>text和image插件，则是允许require.js加载文本和图片文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define([</span><br><span class="line">   &apos;jquery&apos;,</span><br><span class="line">　　　　&apos;text!review.txt&apos;,</span><br><span class="line">　　　　&apos;image!cat.jpg&apos;</span><br><span class="line">　　　　],</span><br><span class="line">　　　　function(review,cat)&#123;</span><br><span class="line">　　　　　　console.log(review);</span><br><span class="line">　　　　　　document.body.appendChild(cat);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　);</span><br></pre></td></tr></table></figure>
<h2 id="工具-r-js"><a href="#工具-r-js" class="headerlink" title="工具 r.js"></a>工具 r.js</h2><p> <strong>RequireJS提供一个基于node.js的命令行工具r.js，用来压缩多个js文件。它的主要作用是将多个模块文件压缩合并成一个脚本文件，以减少网页的HTTP请求数。</strong></p>
<p>第一步是安装r.js（已经安装node.js）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g requirejs</span><br></pre></td></tr></table></figure>
<p>然后，使用的时候，直接在命令行键入以下格式的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node r.js -o &lt;arguments&gt;</span><br></pre></td></tr></table></figure>
<p><argument>表示命令运行时，所需要的一系列参数，比如像下面这样：</argument></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node r.js -o baseUrl=. name=main out=main-built.js</span><br></pre></td></tr></table></figure>
<p>除了直接在命令行提供参数设置，也可以将参数写入一个文件，假定文件名为build.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    baseUrl: &quot;.&quot;,</span><br><span class="line">    name: &quot;main&quot;,</span><br><span class="line">    out: &quot;main-built.js&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后，在命令行下用r.js运行这个参数文件，就OK了，不需要其他步骤了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node r.js -o build.js</span><br></pre></td></tr></table></figure>
<p>下面是一个参数文件的范例，假定位置就在根目录下，文件名为build.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    appDir: &apos;./&apos;,</span><br><span class="line">    baseUrl: &apos;./js&apos;,</span><br><span class="line">    dir: &apos;./dist&apos;,</span><br><span class="line">    modules: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &apos;main&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    fileExclusionRegExp: /^(r|build)\.js$/,</span><br><span class="line">    optimizeCss: &apos;standard&apos;,</span><br><span class="line">    removeCombined: true,</span><br><span class="line">    paths: &#123;</span><br><span class="line">        jquery: &apos;lib/jquery&apos;,</span><br><span class="line">        underscore: &apos;lib/underscore&apos;,</span><br><span class="line">        backbone: &apos;lib/backbone/backbone&apos;,</span><br><span class="line">        backboneLocalstorage: &apos;lib/backbone/backbone.localStorage&apos;,</span><br><span class="line">        text: &apos;lib/require/text&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    shim: &#123;</span><br><span class="line">        underscore: &#123;</span><br><span class="line">            exports: &apos;_&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        backbone: &#123;</span><br><span class="line">            deps: [</span><br><span class="line">                &apos;underscore&apos;,</span><br><span class="line">                &apos;jquery&apos;</span><br><span class="line">            ],</span><br><span class="line">            exports: &apos;Backbone&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        backboneLocalstorage: &#123;</span><br><span class="line">            deps: [&apos;backbone&apos;],</span><br><span class="line">            exports: &apos;Store&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码将多个模块压缩合并成一个main.js。</p>
<p>参数文件的主要成员解释如下：</p>
<ul>
<li><p><strong>appDir</strong>：项目目录，相对于参数文件的位置。</p>
</li>
<li><p><strong>baseUrl</strong>：js文件的位置。</p>
</li>
<li><p><strong>dir</strong>：输出目录。</p>
</li>
<li><p><strong>modules</strong>：一个包含对象的数组，每个对象就是一个要被优化的模块。</p>
</li>
<li><p><strong>fileExclusionRegExp</strong>：凡是匹配这个正则表达式的文件名，都不会被拷贝到输出目录。</p>
</li>
<li><p><strong>optimizeCss</strong>: 自动压缩CSS文件，可取的值包括“none”, “standard”, “standard.keepLines”, “standard.keepComments”, “standard.keepComments.keepLines”。</p>
</li>
<li><p><strong>removeCombined</strong>：如果为true，合并后的原文件将不保留在输出目录中。</p>
</li>
<li><p><strong>paths</strong>：各个模块的相对路径，可以省略js后缀名。</p>
</li>
<li><p><strong>shim</strong>：配置依赖性关系。如果某一个模块不是AMD模式定义的，就可以用shim属性指定模块的依赖性关系和输出值。</p>
</li>
<li><p><strong>generateSourceMaps</strong>：是否要生成source map文件。</p>
</li>
</ul>
<p>更详细的解释可以参考<a href="https://github.com/jrburke/r.js/blob/master/build/example.build.js" target="_blank" rel="external">官方文档</a>。</p>
<p>运行优化命令后，可以前往dist目录查看优化后的文件。</p>
<p>下面是另一个build.js的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    mainConfigFile : &quot;js/main.js&quot;,</span><br><span class="line">    baseUrl: &quot;js&quot;,</span><br><span class="line">    removeCombined: true,</span><br><span class="line">    findNestedDependencies: true,</span><br><span class="line">    dir: &quot;dist&quot;,</span><br><span class="line">    modules: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;main&quot;,</span><br><span class="line">            exclude: [</span><br><span class="line">                &quot;infrastructure&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;infrastructure&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/27/m-rem-layout/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          rem布局移动端自适应页面
        
      </div>
    </a>
  
  
    <a href="/2016/04/28/wechat-shared/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">微信分享和SDK</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="require-1" data-title="Javascript模块化编程 — RequireJS" data-url="http://yoursite.com/2016/05/25/require-1/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 wuyinxing
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>