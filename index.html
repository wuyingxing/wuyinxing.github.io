<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title> 前端笔记</title>

  <meta name="keywords" content=" web前端，移动web，web问题，HTML，HTML5，JavaScript，css3 ">

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/my.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">wuyinxing</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">关于自己</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/wuyinxing" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/wuyinxing" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://zhihu.com/people/wuyinxing" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/API/" style="font-size: 20px;">API</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Node/" style="font-size: 10px;">Node</a> <a href="/tags/base/" style="font-size: 10px;">base</a> <a href="/tags/event/" style="font-size: 10px;">event</a> <a href="/tags/form/" style="font-size: 10px;">form</a> <a href="/tags/globle/" style="font-size: 10px;">globle</a> <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/jQuery/" style="font-size: 20px;">jQuery</a> <a href="/tags/layout/" style="font-size: 10px;">layout</a> <a href="/tags/require/" style="font-size: 10px;">require</a> <a href="/tags/scroll/" style="font-size: 10px;">scroll</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/window/" style="font-size: 10px;">window</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">wuyinxing</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/my.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">wuyinxing</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于自己</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wuyinxing" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/wuyinxing" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://zhihu.com/people/wuyinxing" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-vue-key" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/18/vue-key/" class="article-date">
  	<time datetime="2018-05-18T06:57:29.000Z" itemprop="datePublished">2018-05-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/18/vue-key/">Vue key的用法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>很多人在学习vue的过程中，只是知道v-for语句，添加key就不会有警告，仅仅如此而已！</p>
</blockquote>
<p>我们知道，vue和react都实现了一套虚拟DOM，使我们可以不直接操作DOM元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的Diff算法（这里不做详细介绍）。因此key在日常使用中通常的作用有两点，其中第二点很少人使用：</p>
<p><strong>1. key的作用主要是为了高效的更新虚拟DOM</strong></p>
<p><strong>2. 完整地触发组件的生命周期钩子</strong></p>
<hr>
<p>首先我们聊一下v-for中的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;      </span><br><span class="line">  &lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt;...&lt;/li&gt;</span><br><span class="line">  &lt;li v-for=&quot;(item,key,index) in items&quot; :key=&quot;key&quot;&gt;...&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码是三种常用的Key的使用方式，但是这三种是有区别的，假设item是对象，且有id属性：</p>
<blockquote>
<p>第一种，当id值变化，元素（li）重新渲染，id值无变化，元素（li）不会重新渲染。 </p>
<p>第二种，当id值变化，元素（li）不会重新渲染， 当改变位置时，元素（li）重新渲染。</p>
<p>第三种，当id值变化，元素（li）不会重新渲染， 当改变位置时，元素（li）重新渲染。</p>
</blockquote>
<p>通过上面的三种结论我们得出：</p>
<p><strong>使用v-for渲染元素时，使用元素自身的id属性去指定渲染元素的key值有利于单个元素的重新渲染，若采用其他如v-for提供的index, key等值，在改变渲染出来的DOM结构时，会触发所有元素的重新渲染，当数据过大时，可能会造成性能负担。</strong></p>
<p><strong>因此当我们在使用v-for进行渲染时，尽可能使用渲染元素自身属性的id给渲染的元素绑定一个key值，这样在当前渲染元素的DOM结构发生变化时，能够单独响应该元素而不触发所有元素的渲染。</strong></p>
<hr>
<p>从上面的v-for实例中，如果我们把元素（li）替换成组件，该组件如果重新渲染，则会触发生命周期的钩子。</p>
<p>下面我们通过实例来说明key的另一种使用方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;swiper class=&quot;myswper&quot; ref=&quot;mySwiper&quot; :options=&quot;swiperOption&quot;   :key=&quot;swiperSlides.length&quot; &gt;</span><br><span class="line">    &lt;swiper-slide   class=&quot;swiper-no-swiping&quot; v-for=&quot;(file, index) in swiperSlides&quot; :key=&quot;index&quot;  &gt;</span><br><span class="line">        &lt;img class=&quot;myImgs&quot; :src=&quot;file.url&quot;  :draggable=&quot;false&quot; &gt;</span><br><span class="line">    &lt;/swiper-slide&gt;</span><br><span class="line">&lt;/swiper&gt;</span><br></pre></td></tr></table></figure>
<p>上面这段代码其实是两个组件外层 <code>swiper</code>组件， 里面sort部分是新的组件<code>swiper-slide</code>。 <code>swiper</code>组件也有一个key属性，这样写的目的是当 <code>swiper-slide</code>的数据长度有变化，<code>swiper</code>会重新渲染，然后触发生命周期！</p>
<p>也可以简单的理解为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;A-component :key=&quot;obj.length&quot; &gt;&lt;/A-component&gt;</span><br><span class="line">&lt;B-component  v-for=&quot;(item, index) in obj&quot; :key=&quot;index&quot; &gt;&lt;/B-component&gt;</span><br></pre></td></tr></table></figure>
<p>A组件想要在B组件变化时，重新渲染自己。 我们可以改变他的Key来实现。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/javascript/">javascript</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-promise" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/18/promise/" class="article-date">
  	<time datetime="2017-05-18T06:57:29.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/promise/">Promise对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="首先看一段代码"><a href="#首先看一段代码" class="headerlink" title="首先看一段代码"></a>首先看一段代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">step1(function (value1) &#123;</span><br><span class="line">  step2(value1, function(value2) &#123;</span><br><span class="line">    step3(value2, function(value3) &#123;</span><br><span class="line">      step4(value3, function(value4) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Promises的写法</span><br><span class="line">(new Promise(step1))</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ES6原生提供了Promise对象,所谓Promise对象，就是代表了未来某个将要发生的事件（通常是一个异步操作）</p>
<p>它的好处在于，有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
<p>每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。</p>
<p>这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。</p>
</blockquote>
<h2 id="Promise接口"><a href="#Promise接口" class="headerlink" title="Promise接口"></a>Promise接口</h2><p><strong>Promise对象只有三种状态。</strong></p>
<blockquote>
<p>异步操作“未完成”（pending）</p>
<p>异步操作“已完成”（resolved，又称fulfilled）</p>
<p>异步操作“失败”（rejected）</p>
</blockquote>
<p><strong>这三种的状态的变化途径只有两种。</strong></p>
<blockquote>
<p>异步操作从“未完成”到“已完成”</p>
<p>异步操作从“未完成”到“失败”。</p>
</blockquote>
<p>这种变化只能发生一次，一旦当前状态变为“已完成”或“失败”，就意味着不会再有新的状态变化了。因此，Promise对象的最终结果只有两种。</p>
<blockquote>
<p>异步操作成功，Promise对象传回一个值，状态变为resolved。</p>
<p>异步操作失败，Promise对象抛出一个错误，状态变为rejected。</p>
</blockquote>
<p>Promise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时（变为resolved状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。</p>
<p>基本用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(value) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>上面代码表示，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve方法和reject方法。如果异步操作成功，则用resolve方法将Promise对象的状态变为“成功”（即从pending变为resolved）；如果异步操作失败，则用reject方法将状态变为“失败”（即从pending变为rejected）。</strong></p>
<p>promise实例生成以后，可以用then方法分别指定resolve方法和reject方法的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).then(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;done&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码的timeout方法返回一个Promise实例对象，表示一段时间以后改变自身状态，从而触发then方法绑定的回调函数。</p>
<p>再来看一个关于Promise对象实现ajax的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var getJSON = function(url) &#123;</span><br><span class="line">  var promise = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    var client = new XMLHttpRequest();</span><br><span class="line">    client.open(&quot;GET&quot;, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = &quot;json&quot;;</span><br><span class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">    function handler() &#123;</span><br><span class="line">      if (this.status === 200) &#123; </span><br><span class="line">              resolve(this.response); </span><br><span class="line">          &#125; else &#123; </span><br><span class="line">              reject(new Error(this.statusText)); </span><br><span class="line">          &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  console.log(&apos;Contents: &apos; + json);</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  console.error(&apos;出错了&apos;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>resolve方法和reject方法调用时，都带有参数。它们的参数会被传递给回调函数。reject方法的参数通常是Error对象的实例，而resolve方法的参数除了正常的值以外，还可能是另一个Promise实例，比如像下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(function(resolve, reject)&#123;</span><br><span class="line">  // ... some code</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var p2 = new Promise(function(resolve, reject)&#123;</span><br><span class="line">  // ... some code</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，这时p1的状态就会传递给p2。如果调用的时候，p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是fulfilled或者rejected，那么p2的回调函数将会立刻执行。</p>
<h2 id="Promise-prototype-then方法：链式操作"><a href="#Promise-prototype-then方法：链式操作" class="headerlink" title="Promise.prototype.then方法：链式操作"></a>Promise.prototype.then方法：链式操作</h2><p>Promise.prototype.then方法返回的是一个新的Promise对象，因此可以采用链式写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  return json.post;</span><br><span class="line">&#125;).then(function(post) &#123;</span><br><span class="line">  // proceed</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>如果前一个回调函数返回的是Promise对象，这时后一个回调函数就会等待该Promise对象有了运行结果，才会进一步调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/post/1.json&quot;).then(function(post) &#123;</span><br><span class="line">  return getJSON(post.commentURL);</span><br><span class="line">&#125;).then(function(comments) &#123;</span><br><span class="line">  // 对comments进行处理</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种设计使得嵌套的异步操作，可以被很容易得改写，从回调函数的“横向发展”改为“向下发展”。</p>
<h2 id="Promise-prototype-catch方法：捕捉错误"><a href="#Promise-prototype-catch方法：捕捉错误" class="headerlink" title="Promise.prototype.catch方法：捕捉错误"></a>Promise.prototype.catch方法：捕捉错误</h2><p>Promise.prototype.catch方法是Promise.prototype.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/posts.json&quot;).then(function(posts) &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  // 处理前一个回调函数运行时发生的错误</span><br><span class="line">  console.log(&apos;发生错误！&apos;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/post/1.json&quot;).then(function(post) &#123;</span><br><span class="line">  return getJSON(post.commentURL);</span><br><span class="line">&#125;).then(function(comments) &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  // 处理前两个回调函数的错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Promise-all方法，Promise-race方法"><a href="#Promise-all方法，Promise-race方法" class="headerlink" title="Promise.all方法，Promise.race方法"></a>Promise.all方法，Promise.race方法</h2><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>
<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例。（Promise.all方法的参数不一定是数组，但是必须具有iterator接口，且返回的每个成员都是Promise实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>
<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<p>下面是一个具体的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个Promise对象的数组</span><br><span class="line">var promises = [2, 3, 5, 7, 11, 13].map(function(id)&#123;</span><br><span class="line">  return getJSON(&quot;/post/&quot; + id + &quot;.json&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises).then(function(posts) &#123;</span><br><span class="line">  // ...  </span><br><span class="line">&#125;).catch(function(reason)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.race([p1,p2,p3]);</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值。</p>
<p>如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p>
<h2 id="Promise-resolve方法，Promise-reject方法"><a href="#Promise-resolve方法，Promise-reject方法" class="headerlink" title="Promise.resolve方法，Promise.reject方法"></a>Promise.resolve方法，Promise.reject方法</h2><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;));</span><br></pre></td></tr></table></figure>
<p>上面代码将jQuery生成deferred对象，转为一个新的ES6的Promise对象。</p>
<p>如果Promise.resolve方法的参数，不是具有then方法的对象（又称thenable对象），则返回一个新的Promise对象，且它的状态为fulfilled。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(&apos;Hello&apos;);</span><br><span class="line"></span><br><span class="line">p.then(function (s)&#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br><span class="line">// Hello</span><br></pre></td></tr></table></figure>
<p>上面代码生成一个新的Promise对象的实例p，它的状态为fulfilled，所以回调函数会立即执行，Promise.resolve方法的参数就是回调函数的参数。</p>
<p>如果Promise.resolve方法的参数是一个Promise对象的实例，则会被原封不动地返回。</p>
<p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.reject(&apos;出错了&apos;);</span><br><span class="line"></span><br><span class="line">p.then(null, function (s)&#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure>
<p>上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。</p>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>async函数是用来取代回调函数的另一种方法。</p>
<p>只要函数名之前加上async关键字，就表明该函数内部有异步操作。该异步操作应该返回一个Promise对象，前面用await关键字注明。当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function getStockPrice(symbol, currency) &#123;</span><br><span class="line">    let price = await getStockPrice(symbol);</span><br><span class="line">    return convert(price, currency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数将返回一个Promise对象。调用该函数时，当遇到await关键字，立即返回它后面的表达式（getStockPrice函数）产生的Promise对象，不再执行函数体内后面的语句。等到getStockPrice完成，再自动回到函数体内，执行剩下的语句。</p>
<p>下面是一个更一般性的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function asyncValue(value) &#123;</span><br><span class="line">  await timeout(50);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，asyncValue函数前面有async关键字，表明函数体内有异步操作。执行的时候，遇到await语句就会先返回，等到timeout函数执行完毕，再返回value。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-webStorage" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/11/webStorage/" class="article-date">
  	<time datetime="2016-07-11T02:18:43.646Z" itemprop="datePublished">2016-07-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/webStorage/">localStorage 和 sessionStorage 浏览器端数据储存</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在浏览器端储存数据。它分成两类：sessionStorage和localStorage。</p>
<blockquote>
<p>sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；</p>
<p>localStorage保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</p>
<p>除了保存期限的长短不同，这两个对象的属性和方法完全一样。</p>
</blockquote>
<p>它们很像cookie机制的强化版，能够动用大得多的存储空间。目前，每个域名的存储上限视浏览器而定</p>
<ul>
<li>Chrome是2.5MB</li>
<li>Firefox和Opera是5MB</li>
<li><p>IE是10MB</p>
<p>其中，Firefox的存储空间由一级域名决定，而其他浏览器没有这个限制。也就是说，在Firefox中，a.example.com和b.example.com共享5MB的存储空间。另外，与Cookie一样，它们也受同域限制。某个网页存入的数据，只有同域下的网页才能读取。 </p>
</li>
</ul>
<p>通过检查window对象是否包含sessionStorage和localStorage属性，可以确定浏览器是否支持这两个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// sessionStorage</span><br><span class="line">if (window.sessionStorage) &#123;</span><br><span class="line">  // …………</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// localStorage</span><br><span class="line">if (window.localStorage) &#123;</span><br><span class="line">  // …………</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="存入-读取数据"><a href="#存入-读取数据" class="headerlink" title="存入/读取数据"></a>存入/读取数据</h2><p>sessionStorage和localStorage保存的数据，都以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值</p>
<p><strong>所有的数据都是以文本格式保存。所以存储和读取的值都是文本形式的，注意这个过程的数据类型转化</strong></p>
<p>存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">localStorage.setItem(&quot;key&quot;,&quot;value&quot;);</span><br></pre></td></tr></table></figure>
<p>读取数据使用getItem方法。它只有一个参数，就是键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.getItem(&quot;key&quot;);</span><br><span class="line">localStorage.getItem(&quot;key&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="清除数据"><a href="#清除数据" class="headerlink" title="清除数据"></a>清除数据</h2><p>removeItem方法用于清除某个键名对应的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.removeItem(&apos;key&apos;);</span><br><span class="line">localStorage.removeItem(&apos;key&apos;);</span><br></pre></td></tr></table></figure>
<p>clear方法用于清除所有保存的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.clear();</span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>利用length属性和key方法，可以遍历所有的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; localStorage.length; i++)&#123;</span><br><span class="line">    console.log(localStorage.key(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的key方法，根据位置（从0开始）获得键值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.key(1);</span><br></pre></td></tr></table></figure>
<h2 id="storage事件"><a href="#storage事件" class="headerlink" title="storage事件"></a>storage事件</h2><p>当储存的数据发生变化时，会触发storage事件。我们可以指定这个事件的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;storage&quot;,onStorageChange);</span><br></pre></td></tr></table></figure>
<p>回调函数接受一个event对象作为参数。这个event对象的key属性，保存发生变化的键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function onStorageChange(e) &#123;</span><br><span class="line">     console.log(e.key);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了key属性，event对象的属性还有三个：</p>
<blockquote>
<p>oldValue：更新前的值。如果该键为新增加，则这个属性为null。</p>
<p>newValue：更新后的值。如果该键被删除，则这个属性为null。</p>
<p>url：原始触发storage事件的那个网页的网址。</p>
</blockquote>
<p>值得特别注意的是，该事件不在导致数据变化的当前页面触发。如果浏览器同时打开一个域名下面的多个页面，当其中的一个页面改变sessionStorage或localStorage的数据时，其他所有页面的storage事件会被触发，而原始页面并不触发storage事件。可以通过这种机制，实现多个窗口之间的通信。所有浏览器之中，只有IE浏览器除外，它会在所有页面触发storage事件。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/API/">API</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/browser/">browser</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-m-rem-layout" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/27/m-rem-layout/" class="article-date">
  	<time datetime="2016-05-27T08:49:39.608Z" itemprop="datePublished">2016-05-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/27/m-rem-layout/">rem布局移动端自适应页面</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做了很多移动端web项目，在网页在适应上走了很多弯曲的道路，刚开始采用的是<a href="https://m.dianping.com/" target="_blank" rel="external">大众点评</a>似的布局，百分比布局当然也用到了所谓的<strong>弹性布局</strong><code>flex</code>，有天朋友给我推荐 <a href="https://github.com/jieyou/rem_layout" target="_blank" rel="external"><strong>rem布局</strong></a>，也慢慢开启的对rem的探索！</p>
<p>首先我们来谈谈什么是rem</p>
<h2 id="rem简介"><a href="#rem简介" class="headerlink" title="rem简介"></a>rem简介</h2><p><strong>rem</strong>  是CSS3新引进来的一个度量单位，大家心里肯定会觉得心灰意冷呀，担心浏览器的支持情况。其实大家不用害怕，你可能会惊讶，支持的浏览器还是蛮多的，比如：Mozilla Firefox 3.6+、Apple Safari 5+、Google Chrome、IE9+和Opera11+。只是可怜的IE6-8无法，你们就把他们当透明了吧。</p>
<p><strong>当使用 rem 单位，他们转化为像素大小取决于页根元素的字体大小，即 html 元素的字体大小。 根元素字体大小乘以你 rem 值。</strong></p>
<p>例如，根元素的字体大小 16px，10rem 将等同于 160px，即 10 x 16 = 160。</p>
<p>通常我们设置font-size：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html &#123; font-size: 62.5%; &#125;</span><br></pre></td></tr></table></figure>
<p>因为<strong>任何浏览器的默认字体大小都是16px</strong>，所以也就是说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html &#123; font-size: 10px; &#125;</span><br></pre></td></tr></table></figure>
<p>这样有利于我们队rem 和 em 的换算； 也就是 1rem  = 10px （10px 为根元素的的字体大小）；</p>
<p><strong>问题的引出</strong></p>
<p>这里结合自己对网易与淘宝移动端首页html元素上的font-size这个属性的思考与学习，讨论html5设计稿尺寸以及前端与设计之间协作流程的问题。</p>
<p>如果html5要适应各种分辨率的移动设备，应该使用rem这样的尺寸单位，同时给出了一段针对各个分辨率范围在html上设置font-size的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">html&#123;font-size:10px&#125;</span><br><span class="line">@media screen and (min-width:321px) and (max-width:375px)&#123;html&#123;font-size:11px&#125;&#125;</span><br><span class="line">@media screen and (min-width:376px) and (max-width:414px)&#123;html&#123;font-size:12px&#125;&#125;</span><br><span class="line">@media screen and (min-width:415px) and (max-width:639px)&#123;html&#123;font-size:15px&#125;&#125;</span><br><span class="line">@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:20px&#125;&#125;</span><br><span class="line">@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:22.5px&#125;&#125;</span><br><span class="line">@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:23.5px&#125;&#125;</span><br><span class="line">@media screen and (min-width:800px)&#123;html&#123;font-size:25px&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在实际项目中，把与元素尺寸有关的css，如width,height,line-height,margin,padding等都以rem作为单位，这样页面在不同设备下就能保持一致的网页布局。举例来说，网页有一个.item类，设置了width为3.4rem，该类在不同分辨率下对应的实际宽度如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">321px &lt;= device-width &lt;= 375px，font-size:11px        ---&gt;  .item的width：34px</span><br><span class="line">376px &lt;= device-width &lt;= 414px，font-size:12px        ---&gt;  .item的width：37.4px</span><br><span class="line">415px &lt;= device-width &lt;= 639px，font-size:15px        ---&gt;  .item的width：40.8px</span><br><span class="line">640px &lt;= device-width &lt;= 719px，font-size:20px        ---&gt;  .item的width：51px</span><br><span class="line">720px &lt;= device-width &lt;= 749px，font-size:22.5px      ---&gt;  .item的width：76.5px</span><br><span class="line">750px &lt;= device-width &lt;= 799px，font-size:23.5px      ---&gt;  .item的width：79.8999999px</span><br><span class="line">800px &lt;= device-width         ，font-size:25px        ---&gt;  .item的width：85px</span><br></pre></td></tr></table></figure>
<p>以上代码乍看没啥问题，响应式设计不就应该是这么干的吗？但是从工作量和复杂度方面来考虑，它有以下几个不足：</p>
<p>（1）.item类在所有设备下的width都是3.4rem，但在不同分辨率下的实际像素是不一样的，所以在有些分辨率下，width的界面效果不一定合适，有可能太宽，有可能太窄，这时候就要对width进行调整，那么就需要针对.item写媒介查询的代码，为该分辨率重新设计一个rem值。然而，这里有7种媒介查询的情况，css又有很多跟尺寸相关的属性，哪个属性在哪个分辨率范围不合适都是不定的，最后会导致要写很多的媒介查询才能适配所有设备，而且在写的时候rem都得根据某个分辨率html的font-size去算，这个计算可不见得每次都那么容易，比如40px / 23.5px，这个rem值口算不出来吧！由此可见这其中的麻烦有多少。</p>
<p>（2）以上代码中给出的7个范围下的font-size不一定是合适的，这7个范围也不一定合适，实际有可能不需要这么多，所以找出这些个范围，以及每个范围最合适的font-size也很麻烦</p>
<p>（3）设计稿都是以分辨率来标明尺寸的，前端在根据设计稿里各个元素的像素尺寸转换为rem时，该以哪个font-size为准呢？这需要去写才能知道。<br>正是因为以上提到的一些不足，我觉得这种适配方式不是特别好，写起来太麻烦。为了完成工作，我们需要找寻更简单更有效率的方法。那么html5该如何去做众多移动设备的适配呢？</p>
<h2 id="网易的做法"><a href="#网易的做法" class="headerlink" title="网易的做法"></a>网易的做法</h2><p>先来看看网易在不同分辨率下，呈现的效果：</p>
<p><img src="/images/rem/wy-1.png" alt=""> <img src="/images/rem/wy-2.png" alt=""></p>
<p>从这两张图片可以看出，随着分辨率的增大，页面的效果会发生明显变化，主要体现在各个元素的宽高与间距。375<em>680的比320</em>680的导航栏明显要高。能够达到这种效果的根本原因就是因为网易页面里除了font-size之外的其它css尺寸都使用了rem作为单位，比如你看导航栏的高度设置代码:</p>
<p><img src="/images/rem/height.png" alt=""></p>
<p>使用rem布局结合在html上根据不同分辨率设置不同font-size有很多不好解决的麻烦，网易是如何解决的呢？ </p>
<p>最根本的原因在于，网易页面上html的font-size不是预先通过媒介查询在css里定义好的，而是通过js计算出来的 ，所以当分辨率发生变化时，html的font-size就会变，不过这得在你调整分辨率后，刷新页面才能看得到效果。你看代码就知道为啥font-size是直接写到html的style上面的了（js设置的原因）</p>
<p><img src="/images/rem/wy-3.png" alt=""></p>
<p>它是根据什么计算的，这就跟设计稿有关了，拿网易来说，它的设计稿应该是基于iphone4或者iphone5来的，所以它的设计稿竖直放时的横向分辨率为640px，为了计算方便，取一个100px的font-size为参照，那么body元素的宽度就可以设置为width: 6.4rem，于是html的font-size=deviceWidth / 6.4。这个deviceWidth就是viewport设置中的那个deviceWidth。根据这个计算规则，可得出本部分开始的四张截图中html的font-size大小如下：</p>
<p>deviceWidth = 320，font-size = 320 / 6.4 = 50px<br>deviceWidth = 375，font-size = 375 / 6.4 = 58.59375px<br>deviceWidth = 414，font-size = 414 / 6.4 = 64.6875px<br>deviceWidth = 500，font-size = 500 / 6.4 = 78.125px<br>事实上网易就是这么干的，你看它的代码就知道，body元素的宽是：</p>
<p><img src="/images/rem/wy-4.png" alt=""></p>
<p>根据这个可以肯定它的设计稿竖着时的横向分辨率为640。然后你再看看网易在分辨率为320<em>680，375</em>680，414<em>680，500</em>680时，html的font-size是不是与上面计算的一致：</p>
<p><img src="/images/rem/wy-5.png" alt=""></p>
<p>这个deviceWidth通过document.documentElement.clientWidth就能取到了，所以当页面的dom ready后，做的第一件事情就是：</p>
<p><strong>document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + ‘px’;</strong></p>
<p>这个6.4怎么来的，当然是根据设计稿的横向分辨率/100得来的。下面总结下网易的这种做法：</p>
<ul>
<li>（1）先拿设计稿竖着的横向分辨率除以100得到body元素的宽度：</li>
</ul>
<p>如果设计稿基于iphone6，横向分辨率为750，body的width为750 / 100 = 7.5rem<br>如果设计稿基于iphone4/5，横向分辨率为640，body的width为640 / 100 = 6.4rem</p>
<ul>
<li>（2）布局时，设计图标注的尺寸除以100得到css中的尺寸，比如下图：</li>
</ul>
<p><img src="/images/rem/wy-6.png" alt=""></p>
<p>播放器高度为210px，写样式的时候css应该这么写：height: 2.1rem。之所以取一个100作为参照，就是为了这里计算rem的方便！<br>（3）在dom ready以后，通过以下代码设置html的font-size:<br>document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + ‘px’;<br>6.4只是举个例子，如果是750的设计稿，应该除以7.5。<br>（4）font-size可能需要额外的媒介查询，并且font-size不能使用rem，如网易的设置：<br>@media screen and (max-width:321px){<br>    .m-navlist{font-size:15px}<br>}<br>@media screen and (min-width:321px) and (max-width:400px){<br>    .m-navlist{font-size:16px}<br>}<br>@media screen and (min-width:400px){<br>    .m-navlist{font-size:18px}<br>}<br>最后还有2个情况要说明：</p>
<p>第一，如果采用网易这种做法，视口要如下设置：</p>
<p><meta name="viewport" content="initial-scale=1,maximum-scale=1, minimum-scale=1"><br>第二，当deviceWidth大于设计稿的横向分辨率时，html的font-size始终等于横向分辨率/body元素宽,</p>
<p><img src="/images/rem/wy-7.png" alt=""></p>
<p>之所以这么干，是因为当deviceWidth大于640时，则物理分辨率大于1280（这就看设备的devicePixelRatio这个值了），应该去访问pc网站了。事实就是这样，你从手机访问网易，看到的是触屏版的页面，如果从pad访问，看到的就是电脑版的页面。如果你也想这么干，只要把总结中第三步的代码稍微改一下就行了：</p>
<p>var deviceWidth = document.documentElement.clientWidth;<br>if(deviceWidth &gt; 640) deviceWidth = 640;<br>document.documentElement.style.fontSize = deviceWidth / 6.4 + ‘px’;</p>
<p>然后就把网易代码给拔了下来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">var Dpr = 1, uAgent = window.navigator.userAgent;</span><br><span class="line">var isIOS = uAgent.match(/iphone/i);</span><br><span class="line">var isYIXIN = uAgent.match(/yixin/i);</span><br><span class="line">var is2345 = uAgent.match(/Mb2345/i);</span><br><span class="line">var ishaosou = uAgent.match(/mso_app/i);</span><br><span class="line">var isSogou = uAgent.match(/sogoumobilebrowser/ig);</span><br><span class="line">var isLiebao = uAgent.match(/liebaofast/i);</span><br><span class="line">var isGnbr = uAgent.match(/GNBR/i);</span><br><span class="line">function resizeRoot()&#123;</span><br><span class="line">    var wWidth = (screen.width &gt; 0) ? (window.innerWidth &gt;= screen.width || window.innerWidth == 0) ? screen.width : window.innerWidth : window.innerWidth, wDpr, wFsize;</span><br><span class="line">    var wHeight = (screen.height &gt; 0) ? (window.innerHeight &gt;= screen.height || window.innerHeight == 0) ? screen.height : window.innerHeight : window.innerHeight;</span><br><span class="line">    if (window.devicePixelRatio) &#123;</span><br><span class="line">        wDpr = window.devicePixelRatio;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        wDpr = isIOS ? wWidth &gt; 818 ? 3 : wWidth &gt; 480 ? 2 : 1 : 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isIOS) &#123;</span><br><span class="line">        wWidth = screen.width;</span><br><span class="line">        wHeight = screen.height;</span><br><span class="line">    &#125;</span><br><span class="line">    // if(window.orientation==90||window.orientation==-90)&#123;</span><br><span class="line">    //     wWidth = wHeight;</span><br><span class="line">    // &#125;else if((window.orientation==180||window.orientation==0))&#123;</span><br><span class="line">    // &#125;</span><br><span class="line">    if(wWidth &gt; wHeight)&#123;</span><br><span class="line">        wWidth = wHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    wFsize = wWidth &gt; 1080 ? 144 : wWidth / 7.5;</span><br><span class="line">    wFsize = wFsize &gt; 32 ? wFsize : 32;</span><br><span class="line">    window.screenWidth_ = wWidth;</span><br><span class="line">    if(isYIXIN || is2345 || ishaosou || isSogou || isLiebao || isGnbr)&#123;//YIXIN 和 2345 这里有个刚调用系统浏览器时候的bug，需要一点延迟来获取</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            wWidth = (screen.width &gt; 0) ? (window.innerWidth &gt;= screen.width || window.innerWidth == 0) ? screen.width : window.innerWidth : window.innerWidth;</span><br><span class="line">            wHeight = (screen.height &gt; 0) ? (window.innerHeight &gt;= screen.height || window.innerHeight == 0) ? screen.height : window.innerHeight : window.innerHeight;</span><br><span class="line">            wFsize = wWidth &gt; 1080 ? 144 : wWidth / 7.5;</span><br><span class="line">            wFsize = wFsize &gt; 32 ? wFsize : 32;</span><br><span class="line">            // document.getElementsByTagName(&apos;html&apos;)[0].dataset.dpr = wDpr;</span><br><span class="line">            document.getElementsByTagName(&apos;html&apos;)[0].style.fontSize = wFsize + &apos;px&apos;;</span><br><span class="line">            document.getElementById(&quot;fixed&quot;).style.display=&quot;none&quot;;</span><br><span class="line">        &#125;,500);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        // document.getElementsByTagName(&apos;html&apos;)[0].dataset.dpr = wDpr;</span><br><span class="line">        document.getElementsByTagName(&apos;html&apos;)[0].style.fontSize = wFsize + &apos;px&apos;;</span><br><span class="line">        document.getElementById(&quot;fixed&quot;).style.display=&quot;none&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // alert(&quot;fz=&quot;+wFsize+&quot;;dpr=&quot;+window.devicePixelRatio+&quot;;</span><br><span class="line">    //UA=&quot;+uAgent+&quot;;width=&quot;+wWidth+&quot;;sw=&quot;+screen.width+&quot;;</span><br><span class="line">    //wiw=&quot;+window.innerWidth+&quot;;wsw=&quot;+window.screen.width+window.screen.availWidth);</span><br><span class="line">&#125;</span><br><span class="line">resizeRoot();</span><br></pre></td></tr></table></figure>
<h2 id="淘宝的做法"><a href="#淘宝的做法" class="headerlink" title="淘宝的做法"></a>淘宝的做法</h2><p>淘宝的效果跟网易的效果其实是类似的，随着分辨率的变化，页面元素的尺寸和间距都相应变化，这是因为淘宝的尺寸也是使用了rem的原因。在介绍它的做法之前，先来了解一点关于viewport的知识，通常我们采用如下代码设置viewport:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot;   content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>这样整个网页在设备内显示时的页面宽度就会等于设备逻辑像素大小，也就是device-width。这个device-width的计算公式为：</p>
<p><strong>设备的物理分辨率/(devicePixelRatio * scale)</strong>，在scale为1的情况下，device-width = 设备的物理分辨率/devicePixelRatio 。</p>
<p>devicePixelRatio称为设备像素比，每款设备的devicePixelRatio都是已知，并且不变的，目前高清屏，普遍都是2，不过还有更高的，比如2.5, 3 等，魅族note的手机的devicePixelRatio就是3。淘宝触屏版布局的前提就是viewport的scale根据devicePixelRatio动态设置。</p>
<ul>
<li><p>在devicePixelRatio为2的时候，scale为0.5</p>
</li>
<li><p>在devicePixelRatio为3的时候，scale为0.3333</p>
</li>
</ul>
<p>这么做目的当然是为了保证页面的大小与设计稿保持一致了，比如设计稿如果是750的横向分辨率，那么实际页面的device-width，以iphone6来说，也等于750，这样的话设计稿上标注的尺寸只要除以某一个值就能够转换为rem了。通过js设置viewport的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var scale = 1 / devicePixelRatio;</span><br><span class="line"></span><br><span class="line">document</span><br><span class="line">    .querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;)</span><br><span class="line">    .setAttribute(&apos;content&apos;,&apos;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;);</span><br></pre></td></tr></table></figure>
<p>淘宝布局的第二个要点，就是html元素的font-size的计算公式，font-size = deviceWidth / 10：</p>
<p>接下来要解决的问题是，元素的尺寸该如何计算，比如说设计稿上某一个元素的宽为150px，换算成rem应该怎么算呢？这个值等于设计稿标注尺寸/该设计稿对应的html的font-size。拿淘宝来说的，他们用的设计稿是750的，所以html的font-size就是75，如果某个元素时150px的宽，换算成rem就是150 / 75 = 2rem。总结下淘宝的这些做法：</p>
<p>（1）动态设置viewport的scale</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var scale = 1 / devicePixelRatio;</span><br><span class="line"></span><br><span class="line">document</span><br><span class="line">    .querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;)</span><br><span class="line">    .setAttribute(&apos;content&apos;,&apos;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;);</span><br></pre></td></tr></table></figure>
<p>（2）动态计算html的font-size : <code>document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + &#39;px&#39;;</code></p>
<p>（3）布局的时候，各元素的css尺寸=设计稿标注尺寸/设计稿横向分辨率/10</p>
<p>（4）font-size可能需要额外的媒介查询，并且font-size不使用rem，这一点跟网易是一样的。<br>最后还有一个情况要说明，跟网易一样，淘宝也设置了一个临界点，当设备竖着时横向物理分辨率大于1080时，html的font-size就不会变化了，原因也是一样的，分辨率已经可以去访问电脑版页面了。</p>
<blockquote>
<p> 互联网上还有很多不同的布局方式，但是万变不离其宗，大致的思路就是这个样子的！</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/layout/">layout</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/mobileWeb/">mobileWeb</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-require-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/25/require-1/" class="article-date">
  	<time datetime="2016-05-25T07:52:03.448Z" itemprop="datePublished">2016-05-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/25/require-1/">Javascript模块化编程 — RequireJS</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RequireJS是一个工具库，主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载，从而提高代码的性能和可维护性。它的模块管理遵守AMD规范（Asynchronous Module Definition）。</p>
<p>RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>入门时，我们所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。慢慢的，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。就形成了下面的结构模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  　&lt;script src=&quot;aa.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;bb.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;cc.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;dd.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;ee.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;ff.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的aa.js要在bb.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p>
<p><strong>require.js的诞生，就是为了解决这两个问题：</strong></p>
<blockquote>
<p>1）实现js文件的异步加载，避免网页失去响应；</p>
<p>2）管理模块之间的依赖性，便于代码的编写和维护。</p>
</blockquote>
<h2 id="require-js的加载很简介"><a href="#require-js的加载很简介" class="headerlink" title="require.js的加载很简介"></a>require.js的加载很简介</h2><p>使用require.js的第一步，是先去官方网站下载最新版本。<br>下载后，假定把它放在js子目录下面，就可以加载了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。</p>
<p>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<p>main.js , 是整个网页的入口代码 , 所有代码都从这儿开始运行。</p>
<p>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">alert(&quot;加载成功！&quot;);</span><br></pre></td></tr></table></figure>
<p>但这样的话，就没必要使用require.js了。真正常见的情况是依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> // main.js</span><br><span class="line">require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123;</span><br><span class="line">　　　　// some code here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</p>
<p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<p>下面，我们看一个实际的例子。<br>如果依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;jquery&apos;, &apos;underscore&apos;, &apos;backbone&apos;], function ($, _, Backbone)&#123;</span><br><span class="line">　　　　// some code here</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。代码就写在回调函数中。</p>
<p>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在 main.js的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;lib/jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;lib/underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;lib/backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>另一种则是直接改变基目录（baseUrl）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　baseUrl: &quot;js/lib&quot;,</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>如果某个模块在另一台主机上，也可以直接指定它的网址，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p>
<h1 id="对上述概念的详细解释"><a href="#对上述概念的详细解释" class="headerlink" title=" 对上述概念的详细解释 "></a><strong> 对上述概念的详细解释 </strong></h1><h2 id="1-基本API"><a href="#1-基本API" class="headerlink" title="1.基本API"></a>1.基本API</h2><p>require会定义三个变量：define,require,requirejs，其中require === requirejs，一般使用require更简短</p>
<blockquote>
<p>define 从名字就可以看出这个api是用来定义一个模块,RequireJS要求每个模块放在一个单独的文件里。</p>
<p>require 加载依赖模块，并执行加载完后的回调函数</p>
</blockquote>
<h3 id="1-1-define方法：定义模块"><a href="#1-1-define方法：定义模块" class="headerlink" title="1.1 define方法：定义模块"></a>1.1 define方法：定义模块</h3><h4 id="（1）独立模块"><a href="#（1）独立模块" class="headerlink" title="（1）独立模块"></a>（1）独立模块</h4><p>如果被定义的模块是一个独立模块，不需要依赖任何其他模块，可以直接用define方法生成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">    method1: function() &#123;&#125;,</span><br><span class="line">    method2: function() &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码生成了一个拥有method1、method2两个方法的模块。</p>
<p>把对象写成一个函数，该函数的返回值就是输出的模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(function () &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">	    method1: function() &#123;&#125;,</span><br><span class="line">		method2: function() &#123;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>后一种写法的自由度更高一点，可以在函数体内写一些模块初始化代码。</p>
<p>值得指出的是，define定义的模块可以返回任何值，不限于对象。</p>
<h4 id="（2）非独立模块"><a href="#（2）非独立模块" class="headerlink" title="（2）非独立模块"></a>（2）非独立模块</h4><p>如果被定义的模块需要依赖其他模块，则define方法必须采用下面的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;module1&apos;, &apos;module2&apos;], function(m1, m2) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>define方法的第一个参数是一个数组，它的成员是当前模块所依赖的模块。</strong></p>
<p>比如，[‘module1’, ‘module2’]表示我们定义的这个新模块依赖于module1模块和module2模块，只有先加载这两个模块，新模块才能正常运行。一般情况下，module1模块和module2模块指的是，当前目录下的module1.js文件和module2.js文件，等同于写成[’./module1’, ‘./module2’]。</p>
<p><strong>define方法的第二个参数是一个函数，当前面数组的所有成员加载成功后，它将被调用。</strong></p>
<p>它的参数与数组的成员一一对应，比如function(m1, m2)就表示，这个函数的第一个参数m1对应module1模块，第二个参数m2对应module2模块。这个函数必须返回一个对象，供其他模块调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;module1&apos;, &apos;module2&apos;], function(m1, m2) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        method: function() &#123;</span><br><span class="line">            m1.methodA();</span><br><span class="line">            m2.methodB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码表示新模块返回一个对象，该对象的method方法就是外部调用的接口，menthod方法内部调用了m1模块的methodA方法和m2模块的methodB方法。</p>
<p>需要注意的是，回调函数必须返回一个对象，这个对象就是你定义的模块。</p>
<p>如果依赖的模块很多，参数与模块一一对应的写法非常麻烦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">    [ &apos;dep1&apos;, &apos;dep2&apos;, &apos;dep3&apos;, &apos;dep4&apos;, &apos;dep5&apos;, &apos;dep6&apos;, &apos;dep7&apos;, &apos;dep8&apos;],</span><br><span class="line">    function(dep1,   dep2,   dep3,   dep4,   dep5,   dep6,   dep7,   dep8)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>为了避免像上面代码那样繁琐的写法，RequireJS提供一种更简单的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">    function (require) &#123;</span><br><span class="line">        var dep1 = require(&apos;dep1&apos;),</span><br><span class="line">            dep2 = require(&apos;dep2&apos;),</span><br><span class="line">            dep3 = require(&apos;dep3&apos;),</span><br><span class="line">            dep4 = require(&apos;dep4&apos;),</span><br><span class="line">            dep5 = require(&apos;dep5&apos;),</span><br><span class="line">            dep6 = require(&apos;dep6&apos;),</span><br><span class="line">            dep7 = require(&apos;dep7&apos;),</span><br><span class="line">            dep8 = require(&apos;dep8&apos;);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面是一个define实际运用的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;math&apos;, &apos;graph&apos;], </span><br><span class="line">    function ( math, graph ) &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">            plot: function(x, y)&#123;</span><br><span class="line">                return graph.drawPie(math.randomGrid(x,y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码定义的模块依赖math和graph两个库，然后返回一个具有plot接口的对象。</p>
<p>另一个实际的例子是，通过判断浏览器是否为IE，而选择加载zepto或jQuery。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define((&apos;__proto__&apos; in &#123;&#125; ? [&apos;zepto&apos;] : [&apos;jquery&apos;]), function($) &#123;</span><br><span class="line">    return $;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个中间模块，该模块先判断浏览器是否支持<strong>proto</strong>属性（除了IE，其他浏览器都支持），如果返回true，就加载zepto库，否则加载jQuery库。</p>
<h3 id="1-2-require方法：调用模块"><a href="#1-2-require方法：调用模块" class="headerlink" title="1.2 require方法：调用模块"></a>1.2 require方法：调用模块</h3><p>require方法用于调用模块。它的参数与define方法类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;a&apos;, &apos;b&apos;], function ( a, b ) &#123;</span><br><span class="line">        b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面方法表示加载a和b两个模块，当这两个模块都加载成功后，执行一个回调函数。该回调函数就用来完成具体的任务。</p>
<p>require方法的第一个参数，是一个表示依赖关系的数组。这个数组可以写得很灵活，请看下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require( [ window.JSON ? undefined : &apos;util/json2&apos; ], function ( JSON ) &#123;</span><br><span class="line">  JSON = JSON || window.JSON;</span><br><span class="line"></span><br><span class="line">  console.log( JSON.parse( &apos;&#123; &quot;JSON&quot; : &quot;HERE&quot; &#125;&apos; ) );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码加载JSON模块时，首先判断浏览器是否原生支持JSON对象。如果是的，则将undefined传入回调函数，否则加载util目录下的json2模块。</p>
<p>require方法也可以用在define方法内部。(define中介绍多模块加载提到过)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(function (require) &#123;</span><br><span class="line">   var otherModule = require(&apos;otherModule&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面的例子显示了如何动态加载模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(function ( require ) &#123;</span><br><span class="line">    var isReady = false, foobar;</span><br><span class="line"></span><br><span class="line">    require([&apos;foo&apos;, &apos;bar&apos;], function (foo, bar) &#123;</span><br><span class="line">        isReady = true;</span><br><span class="line">        foobar = foo() + bar();</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    return &#123;</span><br><span class="line">        isReady: isReady,</span><br><span class="line">        foobar: foobar</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码所定义的模块，内部加载了foo和bar两个模块，在没有加载完成前，isReady属性值为false，加载完成后就变成了true。因此，可以根据isReady属性的值，决定下一步的动作。</p>
<p>下面的例子是模块的输出结果是一个promise对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;lib/Deferred&apos;], function( Deferred )&#123;</span><br><span class="line">    var defer = new Deferred(); </span><br><span class="line">    require([&apos;lib/templates/?index.html&apos;,&apos;lib/data/?stats&apos;],</span><br><span class="line">        function( template, data )&#123;</span><br><span class="line">            defer.resolve(&#123; template: template, data:data &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    return defer.promise();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码的define方法返回一个promise对象，可以在该对象的then方法，指定下一步的动作。</p>
<p>如果服务器端采用JSONP模式，则可以直接在require中调用，方法是指定JSONP的callback参数为define。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require( [ </span><br><span class="line">    &quot;http://someapi.com/foo?callback=define&quot;</span><br><span class="line">], function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>require方法允许添加第三个参数，即错误处理的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require(</span><br><span class="line">    [ &quot;backbone&quot; ], </span><br><span class="line">    function ( Backbone ) &#123;</span><br><span class="line">        return Backbone.View.extend(&#123; /* ... */ &#125;);</span><br><span class="line">    &#125;, </span><br><span class="line">    function (err) &#123;</span><br><span class="line">		// ...</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>require对象还允许指定一个全局性的Error事件的监听函数。所有没有被上面的方法捕获的错误，都会被触发这个监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requirejs.onError = function (err) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-配置config方法"><a href="#3-配置config方法" class="headerlink" title="3 配置config方法"></a>3 配置config方法</h2><p>require方法本身也是一个对象，它带有一个config方法，用来配置require.js运行参数。config方法接受一个对象作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这里的jquery模块定义多个位置(2个位置) 如果第一个位置加载失败，则加载第二个位置</span><br><span class="line">require.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        jquery: [</span><br><span class="line">            &apos;//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.0/jquery.min.js&apos;,</span><br><span class="line">            &apos;lib/jquery&apos;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>config方法的参数对象有以下主要成员：</p>
<p>（<strong>1）paths</strong></p>
<p>paths参数指定各个模块的位置。这个位置可以是同一个服务器上的相对位置，也可以是外部网址。<strong>可以为每个模块定义多个位置</strong>，如果第一个位置加载失败，则加载第二个位置，上面的示例就表示如果CDN加载失败，则加载服务器上的备用脚本。需要注意的是，指定本地文件路径时，可以省略文件最后的js后缀名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&quot;jquery&quot;], function($) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码加载jquery模块，因为jquery的路径已经在paths参数中定义了，所以就会到事先设定的位置下载。</p>
<p><strong>（2）baseUrl</strong></p>
<p>baseUrl参数指定本地模块位置的基准目录，即本地模块的路径是相对于哪个目录的。该属性通常由require.js加载时的data-main属性指定。</p>
<p><strong>（3）shim</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        &quot;backbone&quot;: &quot;vendor/backbone&quot;,</span><br><span class="line">        &quot;underscore&quot;: &quot;vendor/underscore&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    shim: &#123;</span><br><span class="line">        &quot;backbone&quot;: &#123;</span><br><span class="line">            deps: [ &quot;underscore&quot; ],</span><br><span class="line">            exports: &quot;Backbone&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;underscore&quot;: &#123;</span><br><span class="line">            exports: &quot;_&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中的backbone和underscore就是非AMD规范的库。shim指定它们的依赖关系（backbone依赖于underscore），以及输出符号（backbone为“Backbone”，underscore为“_”）。</p>
<p>有些库不是AMD兼容的，这时就需要指定shim属性的值。shim可以理解成“垫片”，用来帮助require.js加载非AMD规范的库。</p>
<h2 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h2><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。</p>
<p>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p>
<p>举例来说，md1和md2这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　shim: &#123;</span><br><span class="line">　　　　　　&apos;md1&apos;:&#123;</span><br><span class="line">　　　　　　　　exports: &apos;md.aa&apos;</span><br><span class="line">　　　　　　&#125;,</span><br><span class="line">　　　　　　&apos;md2&apos;: &#123;</span><br><span class="line">　　　　　　　　deps: [&apos;jquery&apos;, &apos;myQuery&apos;],</span><br><span class="line">　　　　　　　　exports: &apos;md.bb&apos;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义:</p>
<blockquote>
<p>（1）exports值（输出的变量名），表明这个模块外部调用时的名称；</p>
<p>（2）deps数组，表明该模块的依赖性。</p>
</blockquote>
<p>比如，jQuery的插件可以这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　shim: &#123;</span><br><span class="line">　　　　&apos;jquery.scroll&apos;: &#123;</span><br><span class="line">　　　　　　deps: [&apos;jquery&apos;],</span><br><span class="line">　　　　　　exports: &apos;jQuery.fn.scroll&apos;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>RequireJS允许使用插件，加载各种格式的数据。完整的插件清单可以查看 <a href="https://github.com/requirejs/requirejs/wiki/Plugins" title="插件" target="_blank" rel="external"><strong>require插件</strong></a>。</p>
<p>下面是插件的例子。</p>
<p>text和image插件，则是允许require.js加载文本和图片文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define([</span><br><span class="line">   &apos;jquery&apos;,</span><br><span class="line">　　　　&apos;text!review.txt&apos;,</span><br><span class="line">　　　　&apos;image!cat.jpg&apos;</span><br><span class="line">　　　　],</span><br><span class="line">　　　　function(review,cat)&#123;</span><br><span class="line">　　　　　　console.log(review);</span><br><span class="line">　　　　　　document.body.appendChild(cat);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　);</span><br></pre></td></tr></table></figure>
<h2 id="工具-r-js"><a href="#工具-r-js" class="headerlink" title="工具 r.js"></a>工具 r.js</h2><p> <strong>RequireJS提供一个基于node.js的命令行工具r.js，用来压缩多个js文件。它的主要作用是将多个模块文件压缩合并成一个脚本文件，以减少网页的HTTP请求数。</strong></p>
<p>第一步是安装r.js（已经安装node.js）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g requirejs</span><br></pre></td></tr></table></figure>
<p>然后，使用的时候，直接在命令行键入以下格式的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node r.js -o &lt;arguments&gt;</span><br></pre></td></tr></table></figure>
<p><argument>表示命令运行时，所需要的一系列参数，比如像下面这样：</argument></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node r.js -o baseUrl=. name=main out=main-built.js</span><br></pre></td></tr></table></figure>
<p>除了直接在命令行提供参数设置，也可以将参数写入一个文件，假定文件名为build.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    baseUrl: &quot;.&quot;,</span><br><span class="line">    name: &quot;main&quot;,</span><br><span class="line">    out: &quot;main-built.js&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后，在命令行下用r.js运行这个参数文件，就OK了，不需要其他步骤了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node r.js -o build.js</span><br></pre></td></tr></table></figure>
<p>下面是一个参数文件的范例，假定位置就在根目录下，文件名为build.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    appDir: &apos;./&apos;,</span><br><span class="line">    baseUrl: &apos;./js&apos;,</span><br><span class="line">    dir: &apos;./dist&apos;,</span><br><span class="line">    modules: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &apos;main&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    fileExclusionRegExp: /^(r|build)\.js$/,</span><br><span class="line">    optimizeCss: &apos;standard&apos;,</span><br><span class="line">    removeCombined: true,</span><br><span class="line">    paths: &#123;</span><br><span class="line">        jquery: &apos;lib/jquery&apos;,</span><br><span class="line">        underscore: &apos;lib/underscore&apos;,</span><br><span class="line">        backbone: &apos;lib/backbone/backbone&apos;,</span><br><span class="line">        backboneLocalstorage: &apos;lib/backbone/backbone.localStorage&apos;,</span><br><span class="line">        text: &apos;lib/require/text&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    shim: &#123;</span><br><span class="line">        underscore: &#123;</span><br><span class="line">            exports: &apos;_&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        backbone: &#123;</span><br><span class="line">            deps: [</span><br><span class="line">                &apos;underscore&apos;,</span><br><span class="line">                &apos;jquery&apos;</span><br><span class="line">            ],</span><br><span class="line">            exports: &apos;Backbone&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        backboneLocalstorage: &#123;</span><br><span class="line">            deps: [&apos;backbone&apos;],</span><br><span class="line">            exports: &apos;Store&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码将多个模块压缩合并成一个main.js。</p>
<p>参数文件的主要成员解释如下：</p>
<ul>
<li><p><strong>appDir</strong>：项目目录，相对于参数文件的位置。</p>
</li>
<li><p><strong>baseUrl</strong>：js文件的位置。</p>
</li>
<li><p><strong>dir</strong>：输出目录。</p>
</li>
<li><p><strong>modules</strong>：一个包含对象的数组，每个对象就是一个要被优化的模块。</p>
</li>
<li><p><strong>fileExclusionRegExp</strong>：凡是匹配这个正则表达式的文件名，都不会被拷贝到输出目录。</p>
</li>
<li><p><strong>optimizeCss</strong>: 自动压缩CSS文件，可取的值包括“none”, “standard”, “standard.keepLines”, “standard.keepComments”, “standard.keepComments.keepLines”。</p>
</li>
<li><p><strong>removeCombined</strong>：如果为true，合并后的原文件将不保留在输出目录中。</p>
</li>
<li><p><strong>paths</strong>：各个模块的相对路径，可以省略js后缀名。</p>
</li>
<li><p><strong>shim</strong>：配置依赖性关系。如果某一个模块不是AMD模式定义的，就可以用shim属性指定模块的依赖性关系和输出值。</p>
</li>
<li><p><strong>generateSourceMaps</strong>：是否要生成source map文件。</p>
</li>
</ul>
<p>更详细的解释可以参考<a href="https://github.com/jrburke/r.js/blob/master/build/example.build.js" target="_blank" rel="external">官方文档</a>。</p>
<p>运行优化命令后，可以前往dist目录查看优化后的文件。</p>
<p>下面是另一个build.js的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    mainConfigFile : &quot;js/main.js&quot;,</span><br><span class="line">    baseUrl: &quot;js&quot;,</span><br><span class="line">    removeCombined: true,</span><br><span class="line">    findNestedDependencies: true,</span><br><span class="line">    dir: &quot;dist&quot;,</span><br><span class="line">    modules: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;main&quot;,</span><br><span class="line">            exclude: [</span><br><span class="line">                &quot;infrastructure&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;infrastructure&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/require/">require</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-wechat-shared" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/wechat-shared/" class="article-date">
  	<time datetime="2016-04-28T06:36:43.684Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/wechat-shared/">微信分享和SDK</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-、最简单的方法"><a href="#1-、最简单的方法" class="headerlink" title="1 、最简单的方法"></a>1 、最简单的方法</h2><blockquote>
<p>标题：会取当前页面title里面的内容。</p>
<p>图片：会取当前页面body内最前面的一张符合条件的图片。</p>
</blockquote>
<p><strong>图片规格有要求：</strong></p>
<p><strong>尺寸必须大于： 300px * 300px<br>把符合以上两个条件的图片放到<code>&lt;img&gt;</code>里，放到页面<code>&lt;body&gt;</code>内的最前面。<br>这样分享时就会取这张图作为缩略图了。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;微信分享&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div style=&apos;margin:0 auto;width:0px;height:0px;overflow:hidden;&apos;&gt;</span><br><span class="line">		&lt;img src=&quot;&quot; width=&apos;300&apos;&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">// 图片实际大小最小不能小于 300*300 ，不能通过设置图片样式 width=800 之类的以期骗过微信</span><br></pre></td></tr></table></figure>
<h2 id="2-微信JS-SDK"><a href="#2-微信JS-SDK" class="headerlink" title="2 微信JS-SDK"></a>2 微信JS-SDK</h2><p>微信JS-SDK是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包（例如：分享回调，扫一扫，支付，打开微信地图等等等）</p>
<p><strong>具体我们可以通过官网地址操作：</strong><a href="https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html" title="微信JS-SDK" target="_blank" rel="external">微信JS-SDK</a>; </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wechat/">wechat</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-event-mousewheel" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/22/event-mousewheel/" class="article-date">
  	<time datetime="2016-04-22T01:40:54.944Z" itemprop="datePublished">2016-04-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/22/event-mousewheel/">浅谈 Mousewheel 事件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Firefox使用DOMMouseScroll，其他的浏览器使用mousewheel。<br>滚动事件触发时Firefox使用detail属性捕捉滚轮信息，其他的浏览器使用wheelDelta。<br>不知道为何在该问题上其他厂商和微软的如此一致。Firefox可以使用addEventListener方法绑定DomMouseScroll事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // &lt;![CDATA[</span><br><span class="line">    var mouseWheel = document.getElementById(&apos;mouseWheel&apos;);</span><br><span class="line">     </span><br><span class="line">    if (mouseWheel.addEventListener) &#123;</span><br><span class="line">         </span><br><span class="line">        mouseWheel.addEventListener(&apos;DOMMouseScroll&apos;, function(event) &#123;</span><br><span class="line">             </span><br><span class="line">            event.target.innerHTML = event.detail;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">            event.preventDefault();</span><br><span class="line">             </span><br><span class="line">        &#125;, false);</span><br><span class="line">    &#125;</span><br><span class="line">    mouseWheel.onmousewheel = function(event) &#123;</span><br><span class="line">         </span><br><span class="line">        event = event || window.event;</span><br><span class="line">        mouseWheel.innerHTML = event.wheelDelta;</span><br><span class="line">        event.returnValue = false;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    // ]]&gt;</span><br><span class="line">    Firefox</span><br><span class="line">    鼠标滚轮向上滚动是-3，向下滚动是3</span><br><span class="line"></span><br><span class="line">    IE</span><br><span class="line">    鼠标滚轮向上滚动是120，向下滚动是-120</span><br><span class="line"></span><br><span class="line">    Safari</span><br><span class="line">    鼠标滚轮向上滚动是360，向下滚动是-360</span><br><span class="line"></span><br><span class="line">    Opera</span><br><span class="line">    鼠标滚轮向上滚动是120，向下滚动是-120</span><br><span class="line"></span><br><span class="line">    Chrome</span><br><span class="line">    鼠标滚轮向上滚动是120，向下滚动是-120</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="模拟触发滚轮事件-并对返回值操作："><a href="#模拟触发滚轮事件-并对返回值操作：" class="headerlink" title="模拟触发滚轮事件 , 并对返回值操作："></a>模拟触发滚轮事件 , 并对返回值操作：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(div).onmousewheel(function(e)&#123;</span><br><span class="line">        var e = window.event || e;</span><br><span class="line">        e.wheelDelta = e.wheelDelta  ± 3 ;</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">$(div).trigger(&apos;mousewheel&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p> “mousewheel” 事件中的 “event.wheelDelta” 属性值：返回的值，如果是正值说明滚轮是向上滚动，如果是负值说明滚轮是向下滚动；返回的值，均为 120 的倍数，即：幅度大小 = 返回的值 / 120。</p>
<p> “DOMMouseScroll” 事件中的 “event.detail” 属性值：返回的值，如果是负值说明滚轮是向上滚动（与 “event.wheelDelta” 正好相反），如果是正值说明滚轮是向下滚动；返回的值，均为 3 的倍数，即：幅度大小 = 返回的值 / 3。</p>
<p> “mousewheel” 事件在 Opera 10+ 中却是个特例，既有 “event.wheelDelta” 属性，也有 “event.detail” 属性。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/event/">event</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-gulp-tools" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/13/gulp-tools/" class="article-date">
  	<time datetime="2016-04-13T06:35:46.430Z" itemprop="datePublished">2016-04-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/13/gulp-tools/">Gulp 任务管理工具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-安装和入门"><a href="#1-安装和入门" class="headerlink" title="1 . 安装和入门"></a>1 . 安装和入门</h1><p><strong> 全局安装 gulp：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --global gulp    </span><br><span class="line"></span><br><span class="line">或者简写</span><br><span class="line"></span><br><span class="line">npm install -g gulp</span><br></pre></td></tr></table></figure>
<p><strong> 作为项目的开发依赖（devDependencies）安装：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev gulp</span><br></pre></td></tr></table></figure>
<p><strong>  在项目根目录下创建一个名为 gulpfile.js 的文件：</strong></p>
<p>项目根目录中的gulpfile.js，是Gulp的配置文件。下面就是一个典型的gulpfile.js文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">var uglify = require(&apos;gulp-uglify&apos;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;minify&apos;, function () &#123;</span><br><span class="line">  gulp.src(&apos;js/app.js&apos;)</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(&apos;build&apos;))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，gulpfile.js加载gulp和gulp-uglify模块之后，使用gulp模块的task方法指定任务minify。</p>
<p>task方法有两个参数，第一个是任务名，第二个是任务函数。</p>
<p>在任务函数中，使用gulp模块的src方法，指定所要处理的文件，然后使用pipe方法，将上一步的输出转为当前的输入，进行链式处理。</p>
<p><strong> task方法的回调函数使用了两次pipe方法，也就是说做了两种处理。</strong></p>
<p>第一种处理是使用gulp-uglify模块，压缩源码；</p>
<p>第二种处理是使用gulp模块的dest方法，将上一步的输出写入本地文件夹，这里是build.js（代码中省略了后缀名js）。</p>
<p>执行minify任务时，就在项目目录中执行下面命令就可以了。</p>
<p><strong>4. 运行 gulp：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gulp minify  </span><br><span class="line"></span><br><span class="line">// 注释：： </span><br><span class="line">$ gulp &lt;taskName&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认的名为 default 的任务（task）将会被运行，如果没有taskName这默认执行叫default 的任务。</p>
<p>想要单独执行特定的任务（task），请输入 gulp [task] [othertask]。</p>
</blockquote>
<p>从上面的例子中可以看到，gulp充分使用了“管道”思想，就是一个数据流（stream）：src方法读入文件产生数据流，dest方法将数据流写入文件，中间是一些中间步骤，每一步都对数据流进行一些处理。</p>
<h1 id="2-gulp模块的方法"><a href="#2-gulp模块的方法" class="headerlink" title="2 . gulp模块的方法"></a>2 . gulp模块的方法</h1><h2 id="src"><a href="#src" class="headerlink" title="src()"></a>src()</h2><p>gulp模块的src方法，用于产生数据流。它的参数表示所要处理的文件，这些指定的文件会转换成数据流。参数的写法一般有以下几种形式。</p>
<blockquote>
<p>js/app.js：指定确切的文件名。</p>
<p>js/*.js：某个目录所有后缀名为js的文件。</p>
<p>js/<em>*/</em>.js：某个目录及其所有子目录中的所有后缀名为js的文件。</p>
<p>!js/app.js：除了js/app.js以外的所有文件。</p>
<p>*.+(js    css)：匹配项目根目录下，所有后缀名为js或css的文件。</p>
</blockquote>
<p>src方法的参数还可以是一个数组，用来指定多个成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src([&apos;js/**/*.js&apos;, &apos;!js/**/*.min.js&apos;])</span><br></pre></td></tr></table></figure>
<h2 id="dest"><a href="#dest" class="headerlink" title="dest()"></a>dest()</h2><p>dest方法将管道的输出写入文件，同时将这些输出继续输出，所以可以依次调用多次dest方法，将输出写入多个目录。如果有目录不存在，将会被新建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(&apos;./client/templates/*.jade&apos;)</span><br><span class="line">  .pipe(jade())</span><br><span class="line">  .pipe(gulp.dest(&apos;./build/templates&apos;))</span><br><span class="line">  .pipe(minify())</span><br><span class="line">  .pipe(gulp.dest(&apos;./build/minified_templates&apos;));</span><br></pre></td></tr></table></figure>
<p>dest方法还可以接受第二个参数，表示配置对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.dest(&apos;build&apos;, &#123;</span><br><span class="line">  cwd: &apos;./app&apos;,</span><br><span class="line">  mode: &apos;0644&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>配置对象有两个字段。cwd字段指定写入路径的基准目录，默认是当前目录；mode字段指定写入文件的权限，默认是0777。</p>
<h2 id="task"><a href="#task" class="headerlink" title="task()"></a>task()</h2><p>task方法用于定义具体的任务。它的第一个参数是任务名，第二个参数是任务函数。下面是一个非常简单的任务函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;greet&apos;, function () &#123;</span><br><span class="line">   console.log(&apos;Hello world!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>task方法还可以指定按顺序运行的一组任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;build&apos;, [&apos;css&apos;, &apos;js&apos;, &apos;imgs&apos;]);</span><br></pre></td></tr></table></figure>
<p>上面代码先指定build任务，它由css、js、imgs三个任务所组成，task方法会并发执行这三个任务。注意，由于每个任务都是异步调用，所以没有办法保证js任务的开始运行的时间，正是css任务运行结束。</p>
<p>如果希望各个任务严格按次序运行，可以把前一个任务写成后一个任务的依赖模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;css&apos;, [&apos;greet&apos;], function () &#123;</span><br><span class="line">   // Deal with CSS here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码表明，css任务依赖greet任务，所以css一定会在greet运行完成后再运行。</p>
<p>task方法的回调函数，还可以接受一个函数作为参数，这对执行异步任务非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 执行shell命令</span><br><span class="line">var exec = require(&apos;child_process&apos;).exec;</span><br><span class="line">gulp.task(&apos;jekyll&apos;, function(cb) &#123;</span><br><span class="line">  // build Jekyll</span><br><span class="line">  exec(&apos;jekyll build&apos;, function(err) &#123;</span><br><span class="line">    if (err) return cb(err); // return error</span><br><span class="line">    cb(); // finished task</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果一个任务的名字为default，就表明它是“默认任务”，在命令行直接输入gulp命令，就会运行该任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;default&apos;, function () &#123;</span><br><span class="line">  // Your default task</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;default&apos;, [&apos;styles&apos;, &apos;jshint&apos;, &apos;watch&apos;]);</span><br></pre></td></tr></table></figure>
<p>执行的时候，直接使用gulp，就会运行styles、jshint、watch三个任务。</p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch()"></a>watch()</h2><p>watch方法用于指定需要监视的文件。一旦这些文件发生变动，就运行指定任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;watch&apos;, function () &#123;</span><br><span class="line">   gulp.watch(&apos;templates/*.tmpl.html&apos;, [&apos;build&apos;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码指定，一旦templates目录中的模板文件发生变化，就运行build任务。</p>
<p>watch方法也可以用回调函数，代替指定的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(&apos;templates/*.tmpl.html&apos;, function (event) &#123;</span><br><span class="line">   console.log(&apos;Event type: &apos; + event.type);</span><br><span class="line">   console.log(&apos;Event path: &apos; + event.path);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.watch(&apos;js/**/*.js&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另一种写法是watch方法所监控的文件发生变化时（修改、增加、删除文件），会触发change事件。可以对change事件指定回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);</span><br><span class="line">watcher.on(&apos;change&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了change事件，watch方法还可能触发以下事件。</p>
<blockquote>
<p>end：回调函数运行完毕时触发。</p>
<p>error：发生错误时触发。</p>
<p>ready：当开始监听文件时触发。</p>
<p>nomatch：没有匹配的监听文件时触发。</p>
</blockquote>
<p>watcher对象还包含其他一些方法。</p>
<blockquote>
<p>watcher.end()：停止watcher对象，不会再调用任务或回调函数。</p>
<p>watcher.files()：返回watcher对象监视的文件。</p>
<p>watcher.add(glob)：增加所要监视的文件，它还可以附件第二个参数，表示回调函数。</p>
<p>watcher.remove(filepath)：从watcher对象中移走一个监视的文件</p>
</blockquote>
<h1 id="3-模块插件"><a href="#3-模块插件" class="headerlink" title="3 . 模块插件"></a>3 . 模块插件</h1><p><strong>和grunt有相同的地方，就是gulp也有相似的插件对文件进行处理，我们需要哪个插件就将其引入</strong></p>
<p><strong> 这里是我之前写的测试demo , 这里都是当时的测试代码！记录下 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    jshint = require(&apos;gulp-jshint&apos;),</span><br><span class="line">    uglify = require(&apos;gulp-uglify&apos;),</span><br><span class="line">    concat = require(&apos;gulp-concat&apos;),</span><br><span class="line">    minifycss = require(&apos;gulp-minify-css&apos;),</span><br><span class="line">    imagemin = require(&apos;gulp-imagemin&apos;),</span><br><span class="line">    cache = require(&apos;gulp-cache&apos;),</span><br><span class="line">    rename = require(&apos;gulp-rename&apos;),</span><br><span class="line">    notify = require(&apos;gulp-notify&apos;),</span><br><span class="line">    minifyHtml = require(&quot;gulp-minify-html&quot;);</span><br><span class="line">    del = require(&apos;del&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gulp.task(&apos;cleanFile&apos;, function(cb) &#123;</span><br><span class="line">    del([&apos;minJS/*&apos;, &apos;minCss/*&apos;], cb)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gulp.task(&apos;minijs&apos;,function () &#123;</span><br><span class="line">   gulp.src(&apos;js/*.js&apos;)</span><br><span class="line">      .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;))</span><br><span class="line">      .pipe(uglify())</span><br><span class="line">      .pipe(gulp.dest(&apos;minJs&apos;))</span><br><span class="line">      .pipe(notify(&#123; message: &apos;js任务完成&apos; &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;minicss&apos;, function () &#123; </span><br><span class="line">    gulp.src([&apos;css/*.css&apos;])</span><br><span class="line">        .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;))</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(&apos;minCss&apos;))</span><br><span class="line">        .pipe(notify(&#123; message: &apos;CSS任务完成&apos; &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;hebin&apos;,function () &#123;</span><br><span class="line">   gulp.src([&apos;js/*.js&apos;])</span><br><span class="line">   	  .pipe(concat(&apos;main.js&apos;))</span><br><span class="line">   	  .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;))</span><br><span class="line">      .pipe(uglify())</span><br><span class="line">      .pipe(gulp.dest(&apos;minJs&apos;))</span><br><span class="line">      .pipe(notify(&#123; message: &apos;js任务完成&apos; &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//好奇怪！！！！！对这里的多个文件写法</span><br><span class="line">gulp.task(&apos;accc&apos;,function () &#123;</span><br><span class="line">   gulp.src([&apos;js/a.js&apos;],[&apos;js/c.js&apos;])</span><br><span class="line">      .pipe(concat(&apos;ac.min.js&apos;))</span><br><span class="line">      .pipe(uglify())</span><br><span class="line">      .pipe(gulp.dest(&apos;minJs&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gulp.task(&apos;haha&apos;, function () &#123;</span><br><span class="line">    gulp.src([&apos;css/*.css&apos;])</span><br><span class="line">        .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;))</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(&apos;haha&apos;))</span><br><span class="line">        .pipe(notify(&#123; message: &apos;CSS任务完成&apos; &#125;));</span><br><span class="line">    gulp.src(&apos;js/*.js&apos;)</span><br><span class="line">      .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;))</span><br><span class="line">      .pipe(uglify())</span><br><span class="line">      .pipe(gulp.dest(&apos;haha&apos;))</span><br><span class="line">      .pipe(notify(&#123; message: &apos;js任务完成&apos; &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;minihtml&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;*.html&apos;) // 要压缩的html文件</span><br><span class="line">    .pipe(minifyHtml()) //压缩</span><br><span class="line">    .pipe(gulp.dest(&apos;html&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gulp.task(&apos;imagemin&apos;,function()&#123;</span><br><span class="line">    // 1. 找到图片</span><br><span class="line">    gulp.src(&apos;images/*.*&apos;)</span><br><span class="line">    // 2. 压缩图片缓存 只有变动的才被压缩</span><br><span class="line">    .pipe(cache(imagemin(&#123; optimizationLevel: 3, progressive: true, interlaced: true &#125;)))</span><br><span class="line">    // 3. 另存图片</span><br><span class="line">    .pipe(gulp.dest(&apos;minImg&apos;))</span><br><span class="line">    .pipe(notify(&#123; message: &apos;Images task complete&apos; &#125;));</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在命令行使用 gulp auto 启动此任务</span><br><span class="line">gulp.task(&apos;auto&apos;, function () &#123;</span><br><span class="line">    // 监听文件修改，当文件被修改则执行 images 任务</span><br><span class="line">    gulp.watch(&apos;images/*.*)&apos;, [&apos;imagemin&apos;]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 使用 gulp.task(&apos;default&apos;) 定义默认任务</span><br><span class="line">// 在命令行使用 gulp 启动 images 任务和 auto 任务</span><br><span class="line">gulp.task(&apos;default&apos;, [&apos;imagemin&apos;, &apos;auto&apos;]);</span><br><span class="line"></span><br><span class="line">// gulp.task(&apos;default&apos;,[&apos;cleanFile&apos;],function () &#123;</span><br><span class="line">//     gulp.start(&apos;minijs&apos;,&apos;minicss&apos;);</span><br><span class="line">// &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="gulp-load-plugins模块"><a href="#gulp-load-plugins模块" class="headerlink" title="gulp-load-plugins模块"></a>gulp-load-plugins模块</h2><p>一般情况下，gulpfile.js中的模块需要一个个加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    jshint = require(&apos;gulp-jshint&apos;),</span><br><span class="line">    uglify = require(&apos;gulp-uglify&apos;),</span><br><span class="line">    concat = require(&apos;gulp-concat&apos;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;js&apos;, function () &#123;</span><br><span class="line">   return gulp.src(&apos;js/*.js&apos;)</span><br><span class="line">      .pipe(jshint())</span><br><span class="line">      .pipe(jshint.reporter(&apos;default&apos;))</span><br><span class="line">      .pipe(uglify())</span><br><span class="line">      .pipe(concat(&apos;app.js&apos;))</span><br><span class="line">      .pipe(gulp.dest(&apos;build&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，除了gulp模块以外，还加载其他很多个模块。</p>
<p>这种一一加载的写法，<strong> 比较麻烦。 </strong></p>
<p><strong> 使用gulp-load-plugins模块，可以加载package.json文件中所有的gulp模块。上面的代码用gulp-load-plugins模块改写，就是下面这样。 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    gulpLoadPlugins = require(&apos;gulp-load-plugins&apos;),</span><br><span class="line">    plugins = gulpLoadPlugins();</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;js&apos;, function () &#123;</span><br><span class="line">   return gulp.src(&apos;js/*.js&apos;)</span><br><span class="line">      .pipe(plugins.jshint())</span><br><span class="line">      .pipe(plugins.jshint.reporter(&apos;default&apos;))</span><br><span class="line">      .pipe(plugins.uglify())</span><br><span class="line">      .pipe(plugins.concat(&apos;app.js&apos;))</span><br><span class="line">      .pipe(gulp.dest(&apos;build&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码假设package.json文件包含以下内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;devDependencies&quot;: &#123;</span><br><span class="line">      &quot;gulp-concat&quot;: &quot;~2.2.0&quot;,</span><br><span class="line">      &quot;gulp-uglify&quot;: &quot;~0.2.1&quot;,</span><br><span class="line">      &quot;gulp-jshint&quot;: &quot;~1.5.1&quot;,</span><br><span class="line">      &quot;gulp&quot;: &quot;~3.5.6&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gulp-livereload模块"><a href="#gulp-livereload模块" class="headerlink" title="gulp-livereload模块"></a>gulp-livereload模块</h2><p>gulp-livereload模块用于自动刷新浏览器，反映出源码的最新变化。它除了模块以外，还需要在浏览器中安装插件，用来配合源码变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    less = require(&apos;gulp-less&apos;),</span><br><span class="line">    livereload = require(&apos;gulp-livereload&apos;),</span><br><span class="line">    watch = require(&apos;gulp-watch&apos;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;less&apos;, function() &#123;</span><br><span class="line">   gulp.src(&apos;less/*.less&apos;)</span><br><span class="line">      .pipe(watch())</span><br><span class="line">      .pipe(less())</span><br><span class="line">      .pipe(gulp.dest(&apos;css&apos;))</span><br><span class="line">      .pipe(livereload());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码监视less文件，一旦编译完成，就自动刷新浏览器。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gulp/">gulp</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/tools/">tools</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-socket" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/11/socket/" class="article-date">
  	<time datetime="2016-04-11T07:26:41.911Z" itemprop="datePublished">2016-04-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/11/socket/">WebSocket</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="socket概述"><a href="#socket概述" class="headerlink" title="socket概述"></a>socket概述</h1><p>HTTP协议是一种无状态协议，服务器端本身不具有识别客户端的能力，必须借助外部机制，比如session和cookie，才能与特定客户端保持对话。这多多少少带来一些不便，尤其在服务器端与客户端需要持续交换数据的场合（比如网络聊天），更是如此。为了解决这个问题，HTML5提出了浏览器的WebSocket API。</p>
<p>WebSocket的主要作用是，允许服务器端与客户端进行全双工（full-duplex）的通信。举例来说，HTTP协议有点像发电子邮件，发出后必须等待对方回信；WebSocket则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。WebSocket协议完全可以取代Ajax方法，用来向服务器端发送文本和二进制数据，而且还没有“同域限制”。</p>
<p>WebSocket不使用HTTP协议，而是使用自己的协议。浏览器发出的WebSocket请求类似于下面的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: null</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>上面的头信息显示，有一个HTTP头是Upgrade。HTTP1.1协议规定，Upgrade头信息表示将通信协议从HTTP/1.1转向该项所指定的协议。“Connection: Upgrade”就表示浏览器通知服务器，如果可以，就升级到webSocket协议。Origin用于验证浏览器域名是否在服务器许可的范围内。Sec-WebSocket-Key则是用于握手协议的密钥，是base64编码的16字节随机字符串。</p>
<p>服务器端的WebSocket回应则是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Origin: null</span><br><span class="line">Sec-WebSocket-Location: ws://example.com/</span><br></pre></td></tr></table></figure>
<p>服务器端同样用“Connection: Upgrade”通知浏览器，需要改变协议。Sec-WebSocket-Accept是服务器在浏览器提供的Sec-WebSocket-Key字符串后面，添加“258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 字符串，然后再取sha-1的hash值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了webSocket请求。Sec-WebSocket-Location表示进行通信的WebSocket网址。</p>
<blockquote>
<p>请注意，WebSocket协议用ws表示。此外，还有wss协议，表示加密的WebSocket协议，对应HTTPs协议。</p>
</blockquote>
<p>成握手以后，WebSocket协议就在TCP协议之上，开始传送数据。</p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>浏览器端对WebSocket协议的处理，无非就是三件事：</p>
<blockquote>
<p>建立连接和断开连接</p>
<p>发送数据和接收数据</p>
<p>处理错误</p>
</blockquote>
<h2 id="1-建立连接和断开连接"><a href="#1-建立连接和断开连接" class="headerlink" title="1.建立连接和断开连接"></a>1.建立连接和断开连接</h2><p>首先，客户端要检查浏览器是否支持WebSocket，使用的方法是查看window对象是否具有WebSocket属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(window.WebSocket != undefined) &#123;</span><br><span class="line">	// WebSocket代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，开始与服务器建立连接（这里假定服务器就是本机的1740端口，需要使用ws协议）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(window.WebSocket != undefined) &#123;</span><br><span class="line">	var connection = new WebSocket(&apos;ws://localhost:1740&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立连接以后的WebSocket实例对象（即上面代码中的connection），有一个readyState属性，表示目前的状态，可以取4个值：</p>
<blockquote>
<p>0： 正在连接</p>
<p>1： 连接成功</p>
<p>2： 正在关闭</p>
<p>3： 连接关闭</p>
</blockquote>
<p>握手协议成功以后，readyState就从0变为1，并触发open事件，这时就可以向服务器发送信息了。我们可以指定open事件的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection.onopen = wsOpen;</span><br><span class="line"></span><br><span class="line">function wsOpen (event) &#123;</span><br><span class="line">	console.log(&apos;Connected to: &apos; + event.currentTarget.URL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭WebSocket连接，会触发close事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">connection.onclose = wsClose;</span><br><span class="line"></span><br><span class="line">function wsClose () &#123;</span><br><span class="line">	console.log(&quot;Closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<h2 id="2-发送数据和接收数据"><a href="#2-发送数据和接收数据" class="headerlink" title="2.发送数据和接收数据"></a>2.发送数据和接收数据</h2><p>连接建立后，客户端通过send方法向服务器端发送数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.send(message);</span><br></pre></td></tr></table></figure>
<p>除了发送字符串，也可以使用 Blob 或 ArrayBuffer 对象发送二进制数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用ArrayBuffer发送canvas图像数据</span><br><span class="line">var img = canvas_context.getImageData(0, 0, 400, 320);</span><br><span class="line">var binary = new Uint8Array(img.data.length);</span><br><span class="line">for (var i = 0; i &lt; img.data.length; i++) &#123;</span><br><span class="line">	binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">connection.send(binary.buffer);</span><br><span class="line"></span><br><span class="line">// 使用Blob发送文件</span><br><span class="line">var file = document.querySelector(&apos;input[type=&quot;file&quot;]&apos;).files[0];</span><br><span class="line">connection.send(file);</span><br></pre></td></tr></table></figure>
<p>客户端收到服务器发送的数据，会触发message事件。可以通过定义message事件的回调函数，来处理服务端返回的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection.onmessage = wsMessage;</span><br><span class="line"></span><br><span class="line">function wsMessage (event) &#123;</span><br><span class="line">	console.log(event.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的回调函数wsMessage的参数为事件对象event，该对象的data属性包含了服务器返回的数据。</p>
<p>如果接收的是二进制数据，需要将连接对象的格式设为blob或arraybuffer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection.binaryType = &apos;arraybuffer&apos;;</span><br><span class="line"></span><br><span class="line">connection.onmessage = function(e) &#123;</span><br><span class="line">  console.log(e.data.byteLength); // ArrayBuffer对象有byteLength属性</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-处理错误"><a href="#3-处理错误" class="headerlink" title="3.处理错误"></a>3.处理错误</h2><p>如果出现错误，浏览器会触发WebSocket实例对象的error事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection.onerror = wsError;</span><br><span class="line"></span><br><span class="line">function wsError(event) &#123;</span><br><span class="line">	console.log(&quot;Error: &quot; + event.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>服务器端需要单独部署处理WebSocket的代码。下面用node.js搭建一个服务器环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer(function(request, response) &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>假设监听3000端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.listen(3000, function() &#123;</span><br><span class="line">    console.log((new Date()) + &apos; Server is listening on port 3000&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接着启动WebSocket服务器。这需要加载websocket库，如果没有安装，可以先使用npm命令安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var WebSocketServer = require(&apos;websocket&apos;).server;</span><br><span class="line">var wsServer = new WebSocketServer(&#123;</span><br><span class="line">    httpServer: server</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>WebSocket服务器建立request事件的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var connection;</span><br><span class="line"></span><br><span class="line">wsServer.on(&apos;request&apos;, function(req)&#123;</span><br><span class="line">    connection = req.accept(&apos;echo-protocol&apos;, req.origin);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码的回调函数接受一个参数req，表示request请求对象。然后，在回调函数内部，建立WebSocket连接connection。接着，就要对connection的message事件指定回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wsServer.on(&apos;request&apos;, function(r)&#123;</span><br><span class="line">    connection = req.accept(&apos;echo-protocol&apos;, req.origin);</span><br><span class="line"></span><br><span class="line">	connection.on(&apos;message&apos;, function(message) &#123;</span><br><span class="line">		var msgString = message.utf8Data;</span><br><span class="line">		connection.sendUTF(msgString);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最后，监听用户的disconnect事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.on(&apos;close&apos;, function(reasonCode, description) &#123;</span><br><span class="line">    console.log(connection.remoteAddress + &apos; disconnected.&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用ws模块，部署一个简单的WebSocket服务器非常容易。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var WebSocketServer = require(&apos;ws&apos;).Server;</span><br><span class="line">var wss = new WebSocketServer(&#123; port: 8080 &#125;);</span><br><span class="line"></span><br><span class="line">wss.on(&apos;connection&apos;, function connection(ws) &#123;</span><br><span class="line">  ws.on(&apos;message&apos;, function incoming(message) &#123;</span><br><span class="line">    console.log(&apos;received: %s&apos;, message);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ws.send(&apos;something&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket.io"></a>Socket.io</h1><p>Socket.io是目前最流行的WebSocket实现，包括服务器和客户端两个部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持WebSocket的浏览器，会自动降为Ajax连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。</p>
<p>第一步，在服务器端的项目根目录下，安装socket.io模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install socket.io</span><br></pre></td></tr></table></figure>
<p>第二步，在根目录下建立app.js，并写入以下代码（假定使用了Express框架）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var app = require(&apos;express&apos;)();</span><br><span class="line">var server = require(&apos;http&apos;).createServer(app);</span><br><span class="line">var io = require(&apos;socket.io&apos;).listen(server);</span><br><span class="line"></span><br><span class="line">server.listen(80);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, function (req, res) &#123;</span><br><span class="line">  res.sendfile(__dirname + &apos;/index.html&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码表示，先建立并运行HTTP服务器。Socket.io的运行建立在HTTP服务器之上。</p>
<p>第三步，将Socket.io插入客户端网页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>然后，在客户端脚本中，建立WebSocket连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var socket = io.connect(&apos;http://localhost&apos;);</span><br></pre></td></tr></table></figure>
<p>由于本例假定WebSocket主机与客户端是同一台机器，所以connect方法的参数是<a href="http://localhost。接着，指定news事件（即服务器端发送news）的回调函数。" target="_blank" rel="external">http://localhost。接着，指定news事件（即服务器端发送news）的回调函数。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.on(&apos;news&apos;, function (data)&#123;</span><br><span class="line">   console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最后，用emit方法向服务器端发送信号，触发服务器端的anotherNews事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.emit(&apos;anotherNews&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，emit方法可以取代Ajax请求，而on方法指定的回调函数，也等同于Ajax的回调函数。</p>
</blockquote>
<p>第四步，在服务器端的app.js，加入以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io.sockets.on(&apos;connection&apos;, function (socket) &#123;</span><br><span class="line">  socket.emit(&apos;news&apos;, &#123; hello: &apos;world&apos; &#125;);</span><br><span class="line">  socket.on(&apos;anotherNews&apos;, function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码的io.sockets.on方法指定connection事件（WebSocket连接建立）的回调函数。在回调函数中，用emit方法向客户端发送数据，触发客户端的news事件。然后，再用on方法指定服务器端anotherNews事件的回调函数。</p>
<p>不管是服务器还是客户端，socket.io提供两个核心方法：emit方法用于发送消息，on方法用于监听对方发送的消息。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/API/">API</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/HTML/">HTML</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-svg" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/31/svg/" class="article-date">
  	<time datetime="2016-03-31T02:12:55.339Z" itemprop="datePublished">2016-03-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/31/svg/">HTML中SVG图像图像处理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>SVG是“可缩放矢量图”（Scalable Vector Graphics）的缩写，是一种描述向量图形的XML格式的标记化语言。也就是说，SVG本质上是文本文件，格式采用XML，可以在浏览器中显示出矢量图像。由于结构是XML格式，使得它可以插入HTML文档，成为DOM的一部分，然后用JavaScript和CSS进行操作。<br>相比传统的图像文件格式（比如JPG和PNG），SVG图像的优势就是文件体积小，并且放大多少倍都不会失真，因此非常合适用于网页。</p>
<p>SVG图像可以用Adobe公司的Illustrator软件、开源软件Inkscape等生成。目前，所有主流浏览器都支持，对于低于IE 9的浏览器，可以使用第三方的polyfills函数库。</p>
<h2 id="插入SVG文件"><a href="#插入SVG文件" class="headerlink" title="插入SVG文件"></a>插入SVG文件</h2><p>SVG插入网页的方法有多种，可以用在img、object、embed、iframe等标签，以及CSS的background-image属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;circle.svg&quot;&gt;</span><br><span class="line">&lt;object id=&quot;object&quot; data=&quot;circle.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;</span><br><span class="line">&lt;embed id=&quot;embed&quot; src=&quot;icon.svg&quot; type=&quot;image/svg+xml&quot;&gt;</span><br><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;icon.svg&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<p>上面是四种在网页中插入SVG图像的方式。</p>
<p>此外，SVG文件还可以插入其他DOM元素，比如div元素，请看下面的例子（使用了jQuery函数库）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;stage&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(&quot;#stage&quot;).load(&apos;icon.svg&apos;,function(response)&#123;</span><br><span class="line">  $(this).addClass(&quot;svgLoaded&quot;);</span><br><span class="line">  if(!response)&#123;</span><br><span class="line">    // 加载失败的处理代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="svg格式"><a href="#svg格式" class="headerlink" title="svg格式"></a>svg格式</h2><p>SVG文件采用XML格式，就是普通的文本文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;300&quot; height=&quot;180&quot;&gt;</span><br><span class="line">  &lt;circle cx=&quot;30&quot;  cy=&quot;50&quot; r=&quot;25&quot; /&gt;</span><br><span class="line">  &lt;circle cx=&quot;90&quot;  cy=&quot;50&quot; r=&quot;25&quot; class=&quot;red&quot; /&gt;</span><br><span class="line">  &lt;circle cx=&quot;150&quot; cy=&quot;50&quot; r=&quot;25&quot; class=&quot;fancy&quot; /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>上面的svg文件，定义了三个圆，它们的cx、cy、r属性分别为x坐标、y坐标和半径。利用class属性，可以为这些圆指定样式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.red &#123;</span><br><span class="line">  fill: red; /* not background-color! */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fancy &#123;</span><br><span class="line">  fill: none;</span><br><span class="line">  stroke: black; /* similar to border-color */</span><br><span class="line">  stroke-width: 3pt; /* similar to border-width */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，fill属性表示填充色，stroke属性表示描边色，stroke-width属性表示边线宽度。</p>
<p>除了circle标签表示圆，SVG文件还可以使用表示其他形状的标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg&gt;</span><br><span class="line">  &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;200&quot; y2=&quot;0&quot; style=&quot;stroke:rgb(0,0,0);stroke-width:1&quot;/&gt;&lt;/line&gt;</span><br><span class="line">  &lt;rect x=&quot;0&quot; y=&quot;0&quot; height=&quot;100&quot; width=&quot;200&quot; style=&quot;stroke: #70d5dd; fill: #dd524b&quot; /&gt;</span><br><span class="line">  &lt;ellipse cx=&quot;60&quot; cy=&quot;60&quot; ry=&quot;40&quot; rx=&quot;20&quot; stroke=&quot;black&quot; stroke-width=&quot;5&quot; fill=&quot;silver&quot;/&gt;&lt;/ellipse&gt;</span><br><span class="line">	&lt;polygon fill=&quot;green&quot; stroke=&quot;orange&quot; stroke-width=&quot;10&quot; points=&quot;350, 75  379,161 469,161 397,215 423,301 350,250 277,301 303,215 231,161 321,161&quot;/&gt;&lt;polygon&gt;</span><br><span class="line">	&lt;path id=&quot;path1&quot; d=&quot;M160.143,196c0,0,62.777-28.033,90-17.143c71.428,28.572,73.952-25.987,84.286-21.428&quot; style=&quot;fill:none;stroke:2;&quot;&gt;&lt;/path&gt;  </span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，line、rect、ellipse、polygon和path标签，分别表示线条、矩形、椭圆、多边形和路径。</p>
<p>g标签用于将多个形状组成一组，表示group。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;300&quot; height=&quot;180&quot;&gt;</span><br><span class="line">  &lt;g transform=&quot;translate(5, 15)&quot;&gt;</span><br><span class="line">    &lt;text x=&quot;0&quot; y=&quot;0&quot;&gt;Howdy!&lt;/text&gt;</span><br><span class="line">    &lt;path d=&quot;M0,50 L50,0 Q100,0 100,50&quot;</span><br><span class="line">      fill=&quot;none&quot; stroke-width=&quot;3&quot; stroke=&quot;black&quot; /&gt;</span><br><span class="line">  &lt;/g&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<h2 id="SVG文件的JavaScript操作"><a href="#SVG文件的JavaScript操作" class="headerlink" title="SVG文件的JavaScript操作"></a>SVG文件的JavaScript操作</h2><ul>
<li>获取SVG DOM<br>如果使用img标签插入SVG文件，则无法获取SVG DOM。使用object、iframe、embed标签，可以获取SVG DOM。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var svgObject = document.getElementById(&quot;object&quot;).contentDocument;</span><br><span class="line">var svgIframe = document.getElementById(&quot;iframe&quot;).contentDocument;</span><br><span class="line">var svgEmbed = document.getElementById(&quot;embed&quot;).getSVGDocument();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于svg文件就是一般的XML文件，因此可以用DOM方法，选取页面元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 改变填充色</span><br><span class="line">document.getElementById(&quot;theCircle&quot;).style.fill = &quot;red&quot;;</span><br><span class="line"></span><br><span class="line">// 改变元素属性</span><br><span class="line">document.getElementById(&quot;theCircle&quot;).setAttribute(&quot;class&quot;, &quot;changedColors&quot;);</span><br><span class="line"></span><br><span class="line">// 绑定事件回调函数</span><br><span class="line">document.getElementById(&quot;theCircle&quot;).addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">   console.log(&quot;clicked&quot;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>读取svg源码<br>由于svg文件就是一个XML代码的文本文件，因此可以通过读取XML代码的方式，读取svg源码。<br>假定网页中有一个svg元素。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;svg-container&quot;&gt;</span><br><span class="line">	&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xml:space=&quot;preserve&quot; width=&quot;500&quot; height=&quot;440&quot;&gt;</span><br><span class="line">		&lt;!-- svg code --&gt;</span><br><span class="line">	&lt;/svg&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用XMLSerializer实例的serializeToString方法，获取svg元素的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var svgString = new XMLSerializer().serializeToString(document.querySelector(&apos;svg&apos;));</span><br></pre></td></tr></table></figure></p>
<ul>
<li>将svg图像转为canvas图像<br>首先，需要新建一个img对象，将svg图像指定到该img对象的src属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">var svg = new Blob([svgString], &#123;type: &quot;image/svg+xml;charset=utf-8&quot;&#125;);</span><br><span class="line"></span><br><span class="line">var DOMURL = self.URL || self.webkitURL || self;</span><br><span class="line">var url = DOMURL.createObjectURL(svg);</span><br><span class="line"></span><br><span class="line">img.src = url;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后，当图像加载完成后，再将它绘制到canvas元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img.onload = function() &#123;</span><br><span class="line">	var canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line">	var ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    ctx.drawImage(img, 0, 0);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/API/">API</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/HTML/">HTML</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 wuyinxing
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>